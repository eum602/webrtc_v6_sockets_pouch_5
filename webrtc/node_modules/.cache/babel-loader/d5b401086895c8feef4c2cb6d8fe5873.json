{"ast":null,"code":"import _regeneratorRuntime from \"/home/usuario1/Desktop/projects_P2P/webrtc_v6_sockets_pouch_3/webrtc/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/usuario1/Desktop/projects_P2P/webrtc_v6_sockets_pouch_3/webrtc/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/home/usuario1/Desktop/projects_P2P/webrtc_v6_sockets_pouch_3/webrtc/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n//const sha256 = require('sha256');\n//import sha256 from 'sha256'\n//const currentNodeUrl = process.argv[3];//jalando la url contenida en el script cuando se inici esta\nimport PouchDB from 'pouchdb';\nimport { v1 } from 'uuid';\nimport PouchdbFind from 'pouchdb-find';\n\nvar Blockchain = function Blockchain() {\n  var _this = this;\n\n  _classCallCheck(this, Blockchain);\n\n  this.createFirstBlockHandler = function (t) {\n    //console.log('recibido en createFirstBlockHandler:',t)\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = t[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var tx = _step.value;\n        var newTx = {\n          amount: tx.amount,\n          sender: tx['sender'],\n          recipient: tx['recipient'],\n          value4: tx['value4'],\n          value5: tx['value5'],\n          transactionId: v1().split('-').join('') //adding a new attribute, latter this must be\n          //sophisticated with cryptogtaphy.\n          //console.log(\"newTx\",newTx)\n\n        };\n\n        _this.pendingTransactions.push(newTx);\n      } //console.log('pending Transactions',this.pendingTransactions)\n\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return _this.createNewBlock(100, '0', '0');\n  };\n\n  this.createNewBlock = function (nonce, previousBlockHash, hash) {\n    var newBlock = {\n      //_id: (this.chain.length + 1).toString(),\n      index: _this.chain.length + 1,\n      timestamp: Date.now(),\n      transactions: _this.pendingTransactions,\n      nonce: nonce,\n      hash: hash,\n      previousBlockHash: previousBlockHash //this.chain.push(newBlock);\n\n    };\n    _this.pendingTransactions = [];\n\n    _this.chain.push(newBlock); //console.log(newBlock)\n\n\n    return newBlock;\n  };\n\n  this.getLastBlock =\n  /*#__PURE__*/\n  _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee() {\n    var idx, options;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            console.log('Entering to get Last Block...');\n            options = {\n              limit: 1,\n              include_docs: true //by default descending false\n\n            };\n            _context.next = 4;\n            return _this.db.allDocs(options, function (err, res) {\n              if (res && res.rows.length > 0) {\n                if (res['rows'][0]['doc'].index) {\n                  idx = res['rows'][0]['doc'].index;\n                }\n              }\n            });\n\n          case 4:\n            console.log(idx);\n            return _context.abrupt(\"return\", idx);\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n  PouchDB.plugin(PouchdbFind);\n  this.chain = [];\n  this.pendingTransactions = [];\n  this.db = new PouchDB('blockchain');\n};\n/*\n\n\nBlockchain.prototype.createNewTransaction = function(amount, sender, recipient,value4,value5) {\n\tconst newTransaction = {\n\t\tamount: amount,\n\t\tsender: sender,\n\t\trecipient: recipient,\n\t\tvalue4:value4,\n\t\tvalue5:value5,\n\t\ttransactionId: uuid().split('-').join('') //adding a new attribute, latter this must be\n\t\t//sophisticated with cryptogtaphy.\n\t};\n\t//this.pendingTransactions.push(newTransaction);\n\t//return newTransaction;\n\tif(typeof(this.getLastBlock())=='undefined') {return 0;\n\t}else{\n\t\t//return this.getLastBlock()['index']+1;\n\t\treturn newTransaction;\n\t}\n\t//return newTransaction;\n};\n\nBlockchain.prototype.addTransactionToPendingTransactions = function(transactionObj) {\n\tthis.pendingTransactions.push(transactionObj);\n\treturn this.getLastBlock()['index'] + 1;\n};\n\n\nBlockchain.prototype.hashBlock = function(previousBlockHash, currentBlockData, nonce) {\n\tconst dataAsString = previousBlockHash + nonce.toString() + JSON.stringify(currentBlockData);\n\tconst hash = sha256(dataAsString);\n\treturn hash;\n};\n\n\nBlockchain.prototype.proofOfWork = function(previousBlockHash, currentBlockData) {\n\tlet nonce = 0;\n\tlet hash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\twhile (hash.substring(0, 6) !== '000000' && hash.substring(0, 6) !== '000001' &&\n\thash.substring(0, 6) !== '000002' && hash.substring(0, 6) !== '000003' &&\n\thash.substring(0, 6) !== '000004' &&\n\thash.substring(0, 6) !== '000005' &&\n\thash.substring(0, 6) !== '000006' &&\n\thash.substring(0, 6) !== '000007' &&\n\thash.substring(0, 6) !== '000008') {\n\t\tnonce++;\n\t\thash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\t}\n\tconsole.log('El nonce del pow es: ' +  hash , '..........', hash);\n\treturn nonce;\n};\n\n\nBlockchain.prototype.chainIsValid = function(blockchain) { //as a parameter a chain enter into this\n\t//function with the name blockchain\n\tlet validChain = true;\n\tfor (var i = 1; i < blockchain.length; i++) {\t\t\n\t\tconst prevBlock = blockchain[i - 1];\n\t\tconsole.log('previous block' + ' : ',prevBlock);\n\t\tconst currentBlock = blockchain[i];\n\t\tconsole.log('block' + i+1 + ' : ',currentBlock);\n\t\t//1. verify the hashes on every block by rehashing them and verifiying the amount of zeros.\n\t\t//const hash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\t\tlet currentBlockData = { transactions: currentBlock['transactions'], index: currentBlock['index'] };\n\t\tlet previousBlockHash = prevBlock['hash'];\n\t\tconst blockHash = this.hashBlock(previousBlockHash, currentBlockData,currentBlock['nonce']);\n\t\tconsole.log('blockHash',blockHash);\n\t\tif (blockHash.substring(0, 6) !== '000000' && blockHash.substring(0, 6) !== '000001' &&\n\t\tblockHash.substring(0, 6) !== '000002' && blockHash.substring(0, 6) !== '000003' &&\n\t\tblockHash.substring(0, 6) !== '000004' &&\n\t\tblockHash.substring(0, 6) !== '000005' &&\n\t\tblockHash.substring(0, 6) !== '000006' &&\n\t\tblockHash.substring(0, 6) !== '000007' &&\n\t\tblockHash.substring(0, 6) !== '000008' ) validChain = false;\n\t\tconsole.log('1. verify the hashes on every block by rehashing them and verifiying the amount of zeros: ',\n\t\tvalidChain);\n\t\t//2. verify the hash of the previous block hash on every current block\n\t\tif (currentBlock['previousBlockHash'] !== prevBlock['hash']) validChain = false;\n\t\tconsole.log('hash anterior',prevBlock['hash'],'previousBlockHash en current block',\n\t\tcurrentBlock['previousBlockHash'])\n\t\tconsole.log('2. verify the hash of the previous hash on every block: ', \n\t\tcurrentBlock['previousBlockHash'] == prevBlock['hash']);\n\t};\n\t//3. verify the initial values on the genesis block\n\tconst genesisBlock = blockchain[0];\n\tconst correctNonce = genesisBlock['nonce'] === 100;\n\tconst correctPreviousBlockHash = genesisBlock['previousBlockHash'] === '0';\n\tconst correctHash = genesisBlock['hash'] === '0';\n\tconst correctTransactions = genesisBlock['transactions'].length === 6;\n\n\tif (!correctNonce || !correctPreviousBlockHash || !correctHash || !correctTransactions) validChain = false;\n\tconsole.log('3. verify the initial values on the genesis block: ',\n\tcorrectNonce && correctPreviousBlockHash && correctHash && correctTransactions);\n\treturn validChain;\n};\n/*\n\nBlockchain.prototype.getBlock = function(blockHash) {\n\tlet correctBlock = null;\n\tthis.chain.forEach(block => {\n\t\tif (block.hash === blockHash) correctBlock = block;\n\t});\n\treturn correctBlock;\n};\n\n\nBlockchain.prototype.getTransaction = function(transactionId) {\n\tlet correctTransaction = null;\n\tlet correctBlock = null;\n\n\tthis.chain.forEach(block => {\n\t\tblock.transactions.forEach(transaction => {\n\t\t\tif (transaction.transactionId === transactionId) {\n\t\t\t\tcorrectTransaction = transaction;\n\t\t\t\tcorrectBlock = block;\n\t\t\t};\n\t\t});\n\t});\n\n\treturn {\n\t\ttransaction: correctTransaction,\n\t\tblock: correctBlock\n\t};\n};\n\n\nBlockchain.prototype.getAddressData = function(address) {\n\tconst addressTransactions = [];\n\tthis.chain.forEach(block => {\n\t\tblock.transactions.forEach(transaction => {\n\t\t\tif(transaction.sender === address || transaction.recipient === address) {\n\t\t\t\taddressTransactions.push(transaction);\n\t\t\t};\n\t\t});\n\t});\n\n\tlet balance = 0;\n\taddressTransactions.forEach(transaction => {\n\t\tif (transaction.recipient === address) balance += transaction.amount;\n\t\telse if (transaction.sender === address) balance -= transaction.amount;\n\t});\n\n\treturn {\n\t\taddressTransactions: addressTransactions,\n\t\taddressBalance: balance\n\t};\n};\n\n\n\n\n*/\n//module.exports = Blockchain;\n\n\nexport { Blockchain as default };","map":{"version":3,"sources":["/home/usuario1/Desktop/projects_P2P/webrtc_v6_sockets_pouch_3/webrtc/src/Blockchain/Blockchain.js"],"names":["PouchDB","v1","PouchdbFind","Blockchain","createFirstBlockHandler","t","tx","newTx","amount","sender","recipient","value4","value5","transactionId","split","join","pendingTransactions","push","createNewBlock","nonce","previousBlockHash","hash","newBlock","index","chain","length","timestamp","Date","now","transactions","getLastBlock","console","log","options","limit","include_docs","db","allDocs","err","res","rows","idx","plugin"],"mappings":"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","sourcesContent":["//const sha256 = require('sha256');\n//import sha256 from 'sha256'\n//const currentNodeUrl = process.argv[3];//jalando la url contenida en el script cuando se inici esta\nimport PouchDB from 'pouchdb'\nimport { v1 } from 'uuid'\nimport PouchdbFind from 'pouchdb-find';\n\nexport default class  Blockchain { \n        \n\tconstructor() {\n\t\tPouchDB.plugin(PouchdbFind)\n\t\tthis.chain = []\n\t\tthis.pendingTransactions = []\n\t\tthis.db = new PouchDB('blockchain')\n\t}\n    \n    createFirstBlockHandler = (t) =>{\n\t\t//console.log('recibido en createFirstBlockHandler:',t)\n        for (let tx of t){\n            const newTx = {\n                amount: tx.amount,\n                sender: tx['sender'],\n                recipient: tx['recipient'],\n                value4:tx['value4'],\n                value5:tx['value5'],\n                transactionId: v1().split('-').join('') //adding a new attribute, latter this must be\n                //sophisticated with cryptogtaphy.\n\t\t\t}\n\t\t\t//console.log(\"newTx\",newTx)\n            this.pendingTransactions.push(newTx)\n\t\t}\n\t\t//console.log('pending Transactions',this.pendingTransactions)\n        return this.createNewBlock(100, '0', '0')\n        \n    }\n\n    createNewBlock = (nonce, previousBlockHash, hash) => {\n        const newBlock = {\n\t\t\t//_id: (this.chain.length + 1).toString(),\n            index: this.chain.length + 1,\n            timestamp: Date.now(),\n            transactions: this.pendingTransactions,\n            nonce: nonce,\n            hash: hash,\n            previousBlockHash: previousBlockHash\n        }\n        \n        //this.chain.push(newBlock);\n        this.pendingTransactions = []\n\t\tthis.chain.push(newBlock)\n\t\t//console.log(newBlock)\n        return newBlock;\n\t}\n\t\n\tgetLastBlock = async() => {\n\t\tconsole.log('Entering to get Last Block...')\n\t\tlet idx\n\t\tlet options = {limit:1,include_docs:true}//by default descending false\n\t\tawait this.db.allDocs(options,(err,res)=>{\n\t\t\tif(res && res.rows.length > 0){\n\t\t\t\tif(res['rows'][0]['doc'].index){\n\t\t\t\t\tidx = res['rows'][0]['doc'].index\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tconsole.log(idx)\n\t\treturn idx\n\t\t\n\t\t/*\n\t\tlet block\n\t\tawait this.db.allDocs({include_docs : true,limit:1},(err,res)=>{\n\t\t\tconsole.log('retrieving last document:', res)\n\t\t\tconst {index,timestamp,transactions,nonce, hash , previousBlockHash} = res['rows'][0]['doc']\n\t\t\tblock = {index,timestamp,transactions,nonce, hash , previousBlockHash}\t\t\t\t\t\t\n\t\t})\n\t\tconsole.log('las block from pouch...' , block)\n\t\treturn block\n\t\t\n\n\t\t/*\n\t\tnew Promise((resolve, reject)=>{\n\t\t\tresolve(this.db.createIndex({index:{fields:[\"index\"]}}))\n\t\t\treject('Error creatingIndex')\n\t\t}).then(results=>{\n\t\t\tconsole.log(\"results de CreateIndex: \", results )\n\t\t\tnew Promise((resolve,reject)=>{\n\t\t\t\tresolve(this.db.find({\n\t\t\t\t\tselector:{\n\t\t\t\t\t\tindex: \"0\"//{$eq:0}\n\t\t\t\t\t}\n\t\t\t\t}))\n\t\t\t\treject('Error when getting with find...')\n\t\t\t})\n\t\t}).then(r=>{\n\t\t\tconsole.log('resultados de la busqueda: ', r)\n\t\t})\n\t\t\n\t\tlet promise = this.db.createIndex({\n\t\t\tindex:{\n\t\t\t\tfields:[\"index\"]\n\t\t\t}\n\t\t})\n\n\t\tpromise.then(results =>{\n\t\t\tconsole.log(\"results de CreateIndex: \", results )\n\t\t})\n\n\t\tlet promise1 = this.db.find({\n\t\t\tselector:{\n\t\t\t\tindex: 0//{$eq:0}\n\t\t\t}\n\t\t})\n\t\t\n\t\tpromise1.then((results=>{\n\t\t\tconsole.log('results: ',results)\n\t\t}))*/\n\n\t\t//return this.chain[this.chain.length - 1];\n\t}\n}\n/*\n\n\nBlockchain.prototype.createNewTransaction = function(amount, sender, recipient,value4,value5) {\n\tconst newTransaction = {\n\t\tamount: amount,\n\t\tsender: sender,\n\t\trecipient: recipient,\n\t\tvalue4:value4,\n\t\tvalue5:value5,\n\t\ttransactionId: uuid().split('-').join('') //adding a new attribute, latter this must be\n\t\t//sophisticated with cryptogtaphy.\n\t};\n\t//this.pendingTransactions.push(newTransaction);\n\t//return newTransaction;\n\tif(typeof(this.getLastBlock())=='undefined') {return 0;\n\t}else{\n\t\t//return this.getLastBlock()['index']+1;\n\t\treturn newTransaction;\n\t}\n\t//return newTransaction;\n};\n\nBlockchain.prototype.addTransactionToPendingTransactions = function(transactionObj) {\n\tthis.pendingTransactions.push(transactionObj);\n\treturn this.getLastBlock()['index'] + 1;\n};\n\n\nBlockchain.prototype.hashBlock = function(previousBlockHash, currentBlockData, nonce) {\n\tconst dataAsString = previousBlockHash + nonce.toString() + JSON.stringify(currentBlockData);\n\tconst hash = sha256(dataAsString);\n\treturn hash;\n};\n\n\nBlockchain.prototype.proofOfWork = function(previousBlockHash, currentBlockData) {\n\tlet nonce = 0;\n\tlet hash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\twhile (hash.substring(0, 6) !== '000000' && hash.substring(0, 6) !== '000001' &&\n\thash.substring(0, 6) !== '000002' && hash.substring(0, 6) !== '000003' &&\n\thash.substring(0, 6) !== '000004' &&\n\thash.substring(0, 6) !== '000005' &&\n\thash.substring(0, 6) !== '000006' &&\n\thash.substring(0, 6) !== '000007' &&\n\thash.substring(0, 6) !== '000008') {\n\t\tnonce++;\n\t\thash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\t}\n\tconsole.log('El nonce del pow es: ' +  hash , '..........', hash);\n\treturn nonce;\n};\n\n\nBlockchain.prototype.chainIsValid = function(blockchain) { //as a parameter a chain enter into this\n\t//function with the name blockchain\n\tlet validChain = true;\n\tfor (var i = 1; i < blockchain.length; i++) {\t\t\n\t\tconst prevBlock = blockchain[i - 1];\n\t\tconsole.log('previous block' + ' : ',prevBlock);\n\t\tconst currentBlock = blockchain[i];\n\t\tconsole.log('block' + i+1 + ' : ',currentBlock);\n\t\t//1. verify the hashes on every block by rehashing them and verifiying the amount of zeros.\n\t\t//const hash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\t\tlet currentBlockData = { transactions: currentBlock['transactions'], index: currentBlock['index'] };\n\t\tlet previousBlockHash = prevBlock['hash'];\n\t\tconst blockHash = this.hashBlock(previousBlockHash, currentBlockData,currentBlock['nonce']);\n\t\tconsole.log('blockHash',blockHash);\n\t\tif (blockHash.substring(0, 6) !== '000000' && blockHash.substring(0, 6) !== '000001' &&\n\t\tblockHash.substring(0, 6) !== '000002' && blockHash.substring(0, 6) !== '000003' &&\n\t\tblockHash.substring(0, 6) !== '000004' &&\n\t\tblockHash.substring(0, 6) !== '000005' &&\n\t\tblockHash.substring(0, 6) !== '000006' &&\n\t\tblockHash.substring(0, 6) !== '000007' &&\n\t\tblockHash.substring(0, 6) !== '000008' ) validChain = false;\n\t\tconsole.log('1. verify the hashes on every block by rehashing them and verifiying the amount of zeros: ',\n\t\tvalidChain);\n\t\t//2. verify the hash of the previous block hash on every current block\n\t\tif (currentBlock['previousBlockHash'] !== prevBlock['hash']) validChain = false;\n\t\tconsole.log('hash anterior',prevBlock['hash'],'previousBlockHash en current block',\n\t\tcurrentBlock['previousBlockHash'])\n\t\tconsole.log('2. verify the hash of the previous hash on every block: ', \n\t\tcurrentBlock['previousBlockHash'] == prevBlock['hash']);\n\t};\n\t//3. verify the initial values on the genesis block\n\tconst genesisBlock = blockchain[0];\n\tconst correctNonce = genesisBlock['nonce'] === 100;\n\tconst correctPreviousBlockHash = genesisBlock['previousBlockHash'] === '0';\n\tconst correctHash = genesisBlock['hash'] === '0';\n\tconst correctTransactions = genesisBlock['transactions'].length === 6;\n\n\tif (!correctNonce || !correctPreviousBlockHash || !correctHash || !correctTransactions) validChain = false;\n\tconsole.log('3. verify the initial values on the genesis block: ',\n\tcorrectNonce && correctPreviousBlockHash && correctHash && correctTransactions);\n\treturn validChain;\n};\n/*\n\nBlockchain.prototype.getBlock = function(blockHash) {\n\tlet correctBlock = null;\n\tthis.chain.forEach(block => {\n\t\tif (block.hash === blockHash) correctBlock = block;\n\t});\n\treturn correctBlock;\n};\n\n\nBlockchain.prototype.getTransaction = function(transactionId) {\n\tlet correctTransaction = null;\n\tlet correctBlock = null;\n\n\tthis.chain.forEach(block => {\n\t\tblock.transactions.forEach(transaction => {\n\t\t\tif (transaction.transactionId === transactionId) {\n\t\t\t\tcorrectTransaction = transaction;\n\t\t\t\tcorrectBlock = block;\n\t\t\t};\n\t\t});\n\t});\n\n\treturn {\n\t\ttransaction: correctTransaction,\n\t\tblock: correctBlock\n\t};\n};\n\n\nBlockchain.prototype.getAddressData = function(address) {\n\tconst addressTransactions = [];\n\tthis.chain.forEach(block => {\n\t\tblock.transactions.forEach(transaction => {\n\t\t\tif(transaction.sender === address || transaction.recipient === address) {\n\t\t\t\taddressTransactions.push(transaction);\n\t\t\t};\n\t\t});\n\t});\n\n\tlet balance = 0;\n\taddressTransactions.forEach(transaction => {\n\t\tif (transaction.recipient === address) balance += transaction.amount;\n\t\telse if (transaction.sender === address) balance -= transaction.amount;\n\t});\n\n\treturn {\n\t\taddressTransactions: addressTransactions,\n\t\taddressBalance: balance\n\t};\n};\n\n\n\n\n*/\n\n\n\n//module.exports = Blockchain;\n\n\n\n"]},"metadata":{},"sourceType":"module"}