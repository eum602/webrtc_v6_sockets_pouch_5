{"ast":null,"code":"import _toConsumableArray from \"/home/usuario1/Desktop/projects_P2P/webrtc_v6_sockets_pouch_3/webrtc/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/usuario1/Desktop/projects_P2P/webrtc_v6_sockets_pouch_3/webrtc/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"/home/usuario1/Desktop/projects_P2P/webrtc_v6_sockets_pouch_3/webrtc/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/usuario1/Desktop/projects_P2P/webrtc_v6_sockets_pouch_3/webrtc/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/usuario1/Desktop/projects_P2P/webrtc_v6_sockets_pouch_3/webrtc/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport React, { Component } from 'react'; //const sha256 = require('sha256');\n\nimport sha256 from 'sha256'; //const currentNodeUrl = process.argv[3];//jalando la url contenida en el script cuando se inici esta\n\nimport { v1 } from 'uuid'; //const uuid = v1()\n\nvar Blockchain =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(Blockchain, _Component);\n\n  function Blockchain(props) {\n    var _this;\n\n    _classCallCheck(this, Blockchain);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Blockchain).call(this, props)); // Don't call this.setState() here!\n\n    _this.createFirstBlockHandler = function (t) {\n      //t = [t1,t2,t3,t4,t5,t6]\n      var pendingTransactions = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = t[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var tx = _step.value;\n          var newTx = {\n            amount: tx.amount,\n            sender: tx['sender'],\n            recipient: tx['recipient'],\n            value4: tx['value4'],\n            value5: tx['value5'],\n            transactionId: v1().split('-').join('') //adding a new attribute, latter this must be\n            //sophisticated with cryptogtaphy.\n\n          };\n          pendingTransactions.push(newTx);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      _this.setState({\n        pendingTransactions: pendingTransactions\n      });\n\n      _this.createNewBlock(100, '0', '0');\n    };\n\n    _this.createNewBlock = function (nonce, previousBlockHash, hash) {\n      var newBlock = {\n        index: _this.state.chain.length + 1,\n        timestamp: Date.now(),\n        transactions: _this.state.pendingTransactions,\n        nonce: nonce,\n        hash: hash,\n        previousBlockHash: previousBlockHash //this.chain.push(newBlock);\n\n      };\n      var pendingTransactions = [];\n\n      var chain = _toConsumableArray(_this.state.chain);\n\n      chain.push(newBlock);\n\n      _this.setState({\n        pendingTransactions: pendingTransactions,\n        chain: chain\n      });\n\n      return newBlock;\n    };\n\n    _this.getLastBlock = function () {\n      return _this.state.chain[_this.state.chain.length - 1];\n    };\n\n    _this.state = {\n      chain: [],\n      pendingTransactions: [] //currentNodeUrl : currentNodeUrl,\n      //networkNodes : []\n      //this.createFirstBlockHandler = this.createFirstBlockHandler.bind(this);\n\n    };\n    return _this;\n  }\n\n  return Blockchain;\n}(Component);\n/*\n\n\nBlockchain.prototype.createNewTransaction = function(amount, sender, recipient,value4,value5) {\n\tconst newTransaction = {\n\t\tamount: amount,\n\t\tsender: sender,\n\t\trecipient: recipient,\n\t\tvalue4:value4,\n\t\tvalue5:value5,\n\t\ttransactionId: uuid().split('-').join('') //adding a new attribute, latter this must be\n\t\t//sophisticated with cryptogtaphy.\n\t};\n\t//this.pendingTransactions.push(newTransaction);\n\t//return newTransaction;\n\tif(typeof(this.getLastBlock())=='undefined') {return 0;\n\t}else{\n\t\t//return this.getLastBlock()['index']+1;\n\t\treturn newTransaction;\n\t}\n\t//return newTransaction;\n};\n\nBlockchain.prototype.addTransactionToPendingTransactions = function(transactionObj) {\n\tthis.pendingTransactions.push(transactionObj);\n\treturn this.getLastBlock()['index'] + 1;\n};\n\n\nBlockchain.prototype.hashBlock = function(previousBlockHash, currentBlockData, nonce) {\n\tconst dataAsString = previousBlockHash + nonce.toString() + JSON.stringify(currentBlockData);\n\tconst hash = sha256(dataAsString);\n\treturn hash;\n};\n\n\nBlockchain.prototype.proofOfWork = function(previousBlockHash, currentBlockData) {\n\tlet nonce = 0;\n\tlet hash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\twhile (hash.substring(0, 6) !== '000000' && hash.substring(0, 6) !== '000001' &&\n\thash.substring(0, 6) !== '000002' && hash.substring(0, 6) !== '000003' &&\n\thash.substring(0, 6) !== '000004' &&\n\thash.substring(0, 6) !== '000005' &&\n\thash.substring(0, 6) !== '000006' &&\n\thash.substring(0, 6) !== '000007' &&\n\thash.substring(0, 6) !== '000008') {\n\t\tnonce++;\n\t\thash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\t}\n\tconsole.log('El nonce del pow es: ' +  hash , '..........', hash);\n\treturn nonce;\n};\n\n\nBlockchain.prototype.chainIsValid = function(blockchain) { //as a parameter a chain enter into this\n\t//function with the name blockchain\n\tlet validChain = true;\n\tfor (var i = 1; i < blockchain.length; i++) {\t\t\n\t\tconst prevBlock = blockchain[i - 1];\n\t\tconsole.log('previous block' + ' : ',prevBlock);\n\t\tconst currentBlock = blockchain[i];\n\t\tconsole.log('block' + i+1 + ' : ',currentBlock);\n\t\t//1. verify the hashes on every block by rehashing them and verifiying the amount of zeros.\n\t\t//const hash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\t\tlet currentBlockData = { transactions: currentBlock['transactions'], index: currentBlock['index'] };\n\t\tlet previousBlockHash = prevBlock['hash'];\n\t\tconst blockHash = this.hashBlock(previousBlockHash, currentBlockData,currentBlock['nonce']);\n\t\tconsole.log('blockHash',blockHash);\n\t\tif (blockHash.substring(0, 6) !== '000000' && blockHash.substring(0, 6) !== '000001' &&\n\t\tblockHash.substring(0, 6) !== '000002' && blockHash.substring(0, 6) !== '000003' &&\n\t\tblockHash.substring(0, 6) !== '000004' &&\n\t\tblockHash.substring(0, 6) !== '000005' &&\n\t\tblockHash.substring(0, 6) !== '000006' &&\n\t\tblockHash.substring(0, 6) !== '000007' &&\n\t\tblockHash.substring(0, 6) !== '000008' ) validChain = false;\n\t\tconsole.log('1. verify the hashes on every block by rehashing them and verifiying the amount of zeros: ',\n\t\tvalidChain);\n\t\t//2. verify the hash of the previous block hash on every current block\n\t\tif (currentBlock['previousBlockHash'] !== prevBlock['hash']) validChain = false;\n\t\tconsole.log('hash anterior',prevBlock['hash'],'previousBlockHash en current block',\n\t\tcurrentBlock['previousBlockHash'])\n\t\tconsole.log('2. verify the hash of the previous hash on every block: ', \n\t\tcurrentBlock['previousBlockHash'] == prevBlock['hash']);\n\t};\n\t//3. verify the initial values on the genesis block\n\tconst genesisBlock = blockchain[0];\n\tconst correctNonce = genesisBlock['nonce'] === 100;\n\tconst correctPreviousBlockHash = genesisBlock['previousBlockHash'] === '0';\n\tconst correctHash = genesisBlock['hash'] === '0';\n\tconst correctTransactions = genesisBlock['transactions'].length === 6;\n\n\tif (!correctNonce || !correctPreviousBlockHash || !correctHash || !correctTransactions) validChain = false;\n\tconsole.log('3. verify the initial values on the genesis block: ',\n\tcorrectNonce && correctPreviousBlockHash && correctHash && correctTransactions);\n\treturn validChain;\n};\n/*\n\nBlockchain.prototype.getBlock = function(blockHash) {\n\tlet correctBlock = null;\n\tthis.chain.forEach(block => {\n\t\tif (block.hash === blockHash) correctBlock = block;\n\t});\n\treturn correctBlock;\n};\n\n\nBlockchain.prototype.getTransaction = function(transactionId) {\n\tlet correctTransaction = null;\n\tlet correctBlock = null;\n\n\tthis.chain.forEach(block => {\n\t\tblock.transactions.forEach(transaction => {\n\t\t\tif (transaction.transactionId === transactionId) {\n\t\t\t\tcorrectTransaction = transaction;\n\t\t\t\tcorrectBlock = block;\n\t\t\t};\n\t\t});\n\t});\n\n\treturn {\n\t\ttransaction: correctTransaction,\n\t\tblock: correctBlock\n\t};\n};\n\n\nBlockchain.prototype.getAddressData = function(address) {\n\tconst addressTransactions = [];\n\tthis.chain.forEach(block => {\n\t\tblock.transactions.forEach(transaction => {\n\t\t\tif(transaction.sender === address || transaction.recipient === address) {\n\t\t\t\taddressTransactions.push(transaction);\n\t\t\t};\n\t\t});\n\t});\n\n\tlet balance = 0;\n\taddressTransactions.forEach(transaction => {\n\t\tif (transaction.recipient === address) balance += transaction.amount;\n\t\telse if (transaction.sender === address) balance -= transaction.amount;\n\t});\n\n\treturn {\n\t\taddressTransactions: addressTransactions,\n\t\taddressBalance: balance\n\t};\n};\n\n\n\n\n*/\n//module.exports = Blockchain;\n\n\nexport { Blockchain as default };","map":{"version":3,"sources":["/home/usuario1/Desktop/projects_P2P/webrtc_v6_sockets_pouch_3/webrtc/src/Blockchain/Blockchain.js"],"names":["React","Component","sha256","v1","Blockchain","props","createFirstBlockHandler","t","pendingTransactions","tx","newTx","amount","sender","recipient","value4","value5","transactionId","split","join","push","setState","createNewBlock","nonce","previousBlockHash","hash","newBlock","index","state","chain","length","timestamp","Date","now","transactions","getLastBlock"],"mappings":";;;;;AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAgC,OAAhC,C,CACA;;AACA,OAAOC,MAAP,MAAmB,QAAnB,C,CACA;;AACA,SAASC,EAAT,QAAmB,MAAnB,C,CACA;;IAEsBC,U;;;;;AAElB,sBAAYC,KAAZ,EAAmB;AAAA;;AAAA;;AACf,oFAAMA,KAAN,GADe,CAEf;;AAFe,UAYnBC,uBAZmB,GAYO,UAACC,CAAD,EAAM;AAC5B;AACA,UAAIC,mBAAmB,GAAG,EAA1B;AAF4B;AAAA;AAAA;;AAAA;AAG5B,6BAAeD,CAAf,8HAAiB;AAAA,cAARE,EAAQ;AACb,cAAMC,KAAK,GAAG;AACVC,YAAAA,MAAM,EAAEF,EAAE,CAACE,MADD;AAEVC,YAAAA,MAAM,EAAEH,EAAE,CAAC,QAAD,CAFA;AAGVI,YAAAA,SAAS,EAAEJ,EAAE,CAAC,WAAD,CAHH;AAIVK,YAAAA,MAAM,EAACL,EAAE,CAAC,QAAD,CAJC;AAKVM,YAAAA,MAAM,EAACN,EAAE,CAAC,QAAD,CALC;AAMVO,YAAAA,aAAa,EAAEb,EAAE,GAAGc,KAAL,CAAW,GAAX,EAAgBC,IAAhB,CAAqB,EAArB,CANL,CAM8B;AACxC;;AAPU,WAAd;AASAV,UAAAA,mBAAmB,CAACW,IAApB,CAAyBT,KAAzB;AACH;AAd2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAe5B,YAAKU,QAAL,CAAc;AAACZ,QAAAA,mBAAmB,EAAnBA;AAAD,OAAd;;AACA,YAAKa,cAAL,CAAoB,GAApB,EAAyB,GAAzB,EAA8B,GAA9B;AACH,KA7BkB;;AAAA,UA+BnBA,cA/BmB,GA+BF,UAACC,KAAD,EAAQC,iBAAR,EAA2BC,IAA3B,EAAoC;AACjD,UAAMC,QAAQ,GAAG;AACbC,QAAAA,KAAK,EAAE,MAAKC,KAAL,CAAWC,KAAX,CAAiBC,MAAjB,GAA0B,CADpB;AAEbC,QAAAA,SAAS,EAAEC,IAAI,CAACC,GAAL,EAFE;AAGbC,QAAAA,YAAY,EAAE,MAAKN,KAAL,CAAWnB,mBAHZ;AAIbc,QAAAA,KAAK,EAAEA,KAJM;AAKbE,QAAAA,IAAI,EAAEA,IALO;AAMbD,QAAAA,iBAAiB,EAAEA,iBANN,CASjB;;AATiB,OAAjB;AAUA,UAAIf,mBAAmB,GAAG,EAA1B;;AACA,UAAIoB,KAAK,sBAAO,MAAKD,KAAL,CAAWC,KAAlB,CAAT;;AACAA,MAAAA,KAAK,CAACT,IAAN,CAAWM,QAAX;;AACA,YAAKL,QAAL,CAAc;AAACZ,QAAAA,mBAAmB,EAAnBA,mBAAD;AAAqBoB,QAAAA,KAAK,EAALA;AAArB,OAAd;;AACA,aAAOH,QAAP;AACN,KA/CqB;;AAAA,UAiDtBS,YAjDsB,GAiDP,YAAM;AACpB,aAAO,MAAKP,KAAL,CAAWC,KAAX,CAAiB,MAAKD,KAAL,CAAWC,KAAX,CAAiBC,MAAjB,GAA0B,CAA3C,CAAP;AACA,KAnDqB;;AAGf,UAAKF,KAAL,GAAa;AACTC,MAAAA,KAAK,EAAG,EADC;AAETpB,MAAAA,mBAAmB,EAAG,EAFb,CAGT;AACA;AAEJ;;AANa,KAAb;AAHe;AAUlB;;;EAZoCP,S;AAwDzC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4JA;;;SApNsBG,U","sourcesContent":["import React , {Component} from 'react'\n//const sha256 = require('sha256');\nimport sha256 from 'sha256'\n//const currentNodeUrl = process.argv[3];//jalando la url contenida en el script cuando se inici esta\nimport { v1 } from 'uuid';\n//const uuid = v1()\n\nexport default class  Blockchain extends Component {\n\n    constructor(props) {\n        super(props)\n        // Don't call this.setState() here!\n        this.state = {\n            chain : [],\n            pendingTransactions : [],\n            //currentNodeUrl : currentNodeUrl,\n            //networkNodes : []\n        }\n        //this.createFirstBlockHandler = this.createFirstBlockHandler.bind(this);\n    }\n\n    createFirstBlockHandler = (t) =>{\n        //t = [t1,t2,t3,t4,t5,t6]\n        let pendingTransactions = []\n        for (let tx of t){      \n            const newTx = {\n                amount: tx.amount,\n                sender: tx['sender'],\n                recipient: tx['recipient'],\n                value4:tx['value4'],\n                value5:tx['value5'],\n                transactionId: v1().split('-').join('') //adding a new attribute, latter this must be\n                //sophisticated with cryptogtaphy.\n            }\n            pendingTransactions.push(newTx)\n        }\n        this.setState({pendingTransactions})\n        this.createNewBlock(100, '0', '0')        \n    }\n\n    createNewBlock = (nonce, previousBlockHash, hash) => {\n        const newBlock = {\n            index: this.state.chain.length + 1,\n            timestamp: Date.now(),\n            transactions: this.state.pendingTransactions,\n            nonce: nonce,\n            hash: hash,\n            previousBlockHash: previousBlockHash\n        }   \n        \n        //this.chain.push(newBlock);\n        let pendingTransactions = []\n        let chain = [...this.state.chain]\n        chain.push(newBlock)\n        this.setState({pendingTransactions,chain})    \n        return newBlock;\n\t}\n\t\n\tgetLastBlock = () => {\n\t\treturn this.state.chain[this.state.chain.length - 1];\n\t}\n\n}\n/*\n\n\nBlockchain.prototype.createNewTransaction = function(amount, sender, recipient,value4,value5) {\n\tconst newTransaction = {\n\t\tamount: amount,\n\t\tsender: sender,\n\t\trecipient: recipient,\n\t\tvalue4:value4,\n\t\tvalue5:value5,\n\t\ttransactionId: uuid().split('-').join('') //adding a new attribute, latter this must be\n\t\t//sophisticated with cryptogtaphy.\n\t};\n\t//this.pendingTransactions.push(newTransaction);\n\t//return newTransaction;\n\tif(typeof(this.getLastBlock())=='undefined') {return 0;\n\t}else{\n\t\t//return this.getLastBlock()['index']+1;\n\t\treturn newTransaction;\n\t}\n\t//return newTransaction;\n};\n\nBlockchain.prototype.addTransactionToPendingTransactions = function(transactionObj) {\n\tthis.pendingTransactions.push(transactionObj);\n\treturn this.getLastBlock()['index'] + 1;\n};\n\n\nBlockchain.prototype.hashBlock = function(previousBlockHash, currentBlockData, nonce) {\n\tconst dataAsString = previousBlockHash + nonce.toString() + JSON.stringify(currentBlockData);\n\tconst hash = sha256(dataAsString);\n\treturn hash;\n};\n\n\nBlockchain.prototype.proofOfWork = function(previousBlockHash, currentBlockData) {\n\tlet nonce = 0;\n\tlet hash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\twhile (hash.substring(0, 6) !== '000000' && hash.substring(0, 6) !== '000001' &&\n\thash.substring(0, 6) !== '000002' && hash.substring(0, 6) !== '000003' &&\n\thash.substring(0, 6) !== '000004' &&\n\thash.substring(0, 6) !== '000005' &&\n\thash.substring(0, 6) !== '000006' &&\n\thash.substring(0, 6) !== '000007' &&\n\thash.substring(0, 6) !== '000008') {\n\t\tnonce++;\n\t\thash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\t}\n\tconsole.log('El nonce del pow es: ' +  hash , '..........', hash);\n\treturn nonce;\n};\n\n\nBlockchain.prototype.chainIsValid = function(blockchain) { //as a parameter a chain enter into this\n\t//function with the name blockchain\n\tlet validChain = true;\n\tfor (var i = 1; i < blockchain.length; i++) {\t\t\n\t\tconst prevBlock = blockchain[i - 1];\n\t\tconsole.log('previous block' + ' : ',prevBlock);\n\t\tconst currentBlock = blockchain[i];\n\t\tconsole.log('block' + i+1 + ' : ',currentBlock);\n\t\t//1. verify the hashes on every block by rehashing them and verifiying the amount of zeros.\n\t\t//const hash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\t\tlet currentBlockData = { transactions: currentBlock['transactions'], index: currentBlock['index'] };\n\t\tlet previousBlockHash = prevBlock['hash'];\n\t\tconst blockHash = this.hashBlock(previousBlockHash, currentBlockData,currentBlock['nonce']);\n\t\tconsole.log('blockHash',blockHash);\n\t\tif (blockHash.substring(0, 6) !== '000000' && blockHash.substring(0, 6) !== '000001' &&\n\t\tblockHash.substring(0, 6) !== '000002' && blockHash.substring(0, 6) !== '000003' &&\n\t\tblockHash.substring(0, 6) !== '000004' &&\n\t\tblockHash.substring(0, 6) !== '000005' &&\n\t\tblockHash.substring(0, 6) !== '000006' &&\n\t\tblockHash.substring(0, 6) !== '000007' &&\n\t\tblockHash.substring(0, 6) !== '000008' ) validChain = false;\n\t\tconsole.log('1. verify the hashes on every block by rehashing them and verifiying the amount of zeros: ',\n\t\tvalidChain);\n\t\t//2. verify the hash of the previous block hash on every current block\n\t\tif (currentBlock['previousBlockHash'] !== prevBlock['hash']) validChain = false;\n\t\tconsole.log('hash anterior',prevBlock['hash'],'previousBlockHash en current block',\n\t\tcurrentBlock['previousBlockHash'])\n\t\tconsole.log('2. verify the hash of the previous hash on every block: ', \n\t\tcurrentBlock['previousBlockHash'] == prevBlock['hash']);\n\t};\n\t//3. verify the initial values on the genesis block\n\tconst genesisBlock = blockchain[0];\n\tconst correctNonce = genesisBlock['nonce'] === 100;\n\tconst correctPreviousBlockHash = genesisBlock['previousBlockHash'] === '0';\n\tconst correctHash = genesisBlock['hash'] === '0';\n\tconst correctTransactions = genesisBlock['transactions'].length === 6;\n\n\tif (!correctNonce || !correctPreviousBlockHash || !correctHash || !correctTransactions) validChain = false;\n\tconsole.log('3. verify the initial values on the genesis block: ',\n\tcorrectNonce && correctPreviousBlockHash && correctHash && correctTransactions);\n\treturn validChain;\n};\n/*\n\nBlockchain.prototype.getBlock = function(blockHash) {\n\tlet correctBlock = null;\n\tthis.chain.forEach(block => {\n\t\tif (block.hash === blockHash) correctBlock = block;\n\t});\n\treturn correctBlock;\n};\n\n\nBlockchain.prototype.getTransaction = function(transactionId) {\n\tlet correctTransaction = null;\n\tlet correctBlock = null;\n\n\tthis.chain.forEach(block => {\n\t\tblock.transactions.forEach(transaction => {\n\t\t\tif (transaction.transactionId === transactionId) {\n\t\t\t\tcorrectTransaction = transaction;\n\t\t\t\tcorrectBlock = block;\n\t\t\t};\n\t\t});\n\t});\n\n\treturn {\n\t\ttransaction: correctTransaction,\n\t\tblock: correctBlock\n\t};\n};\n\n\nBlockchain.prototype.getAddressData = function(address) {\n\tconst addressTransactions = [];\n\tthis.chain.forEach(block => {\n\t\tblock.transactions.forEach(transaction => {\n\t\t\tif(transaction.sender === address || transaction.recipient === address) {\n\t\t\t\taddressTransactions.push(transaction);\n\t\t\t};\n\t\t});\n\t});\n\n\tlet balance = 0;\n\taddressTransactions.forEach(transaction => {\n\t\tif (transaction.recipient === address) balance += transaction.amount;\n\t\telse if (transaction.sender === address) balance -= transaction.amount;\n\t});\n\n\treturn {\n\t\taddressTransactions: addressTransactions,\n\t\taddressBalance: balance\n\t};\n};\n\n\n\n\n*/\n\n\n\n//module.exports = Blockchain;\n\n\n\n"]},"metadata":{},"sourceType":"module"}