{"ast":null,"code":"import _classCallCheck from \"/home/usuario1/Desktop/projects_P2P/webrtc_v6_sockets_pouch_3/webrtc/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n//const sha256 = require('sha256');\n//import sha256 from 'sha256'\n//const currentNodeUrl = process.argv[3];//jalando la url contenida en el script cuando se inici esta\nimport { v1 } from 'uuid';\n\nvar Blockchain = function Blockchain(_t) {\n  var _this = this;\n\n  _classCallCheck(this, Blockchain);\n\n  this.createFirstBlockHandler = function (t) {\n    //console.log('recibido en createFirstBlockHandler:',t)\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = t[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var tx = _step.value;\n        var newTx = {\n          amount: tx.amount,\n          sender: tx['sender'],\n          recipient: tx['recipient'],\n          value4: tx['value4'],\n          value5: tx['value5'],\n          transactionId: v1().split('-').join('') //adding a new attribute, latter this must be\n          //sophisticated with cryptogtaphy.\n          //console.log(\"newTx\",newTx)\n\n        };\n\n        _this.pendingTransactions.push(newTx);\n      } //console.log('pending Transactions',this.pendingTransactions)\n\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return _this.createNewBlock(100, '0', '0');\n  };\n\n  this.createNewBlock = function (nonce, previousBlockHash, hash) {\n    var newBlock = {\n      index: _this.chain.length + 1,\n      timestamp: Date.now(),\n      transactions: _this.pendingTransactions,\n      nonce: nonce,\n      hash: hash,\n      previousBlockHash: previousBlockHash //this.chain.push(newBlock);\n\n    };\n    _this.pendingTransactions = [];\n\n    _this.chain.push(newBlock); //console.log(newBlock)\n\n\n    return newBlock;\n  };\n\n  this.getLastBlock = function () {\n    return _this.chain[_this.chain.length - 1];\n  };\n\n  this.chain = [];\n  this.pendingTransactions = [];\n  this.createFirstBlockHandler(_t);\n};\n/*\n\n\nBlockchain.prototype.createNewTransaction = function(amount, sender, recipient,value4,value5) {\n\tconst newTransaction = {\n\t\tamount: amount,\n\t\tsender: sender,\n\t\trecipient: recipient,\n\t\tvalue4:value4,\n\t\tvalue5:value5,\n\t\ttransactionId: uuid().split('-').join('') //adding a new attribute, latter this must be\n\t\t//sophisticated with cryptogtaphy.\n\t};\n\t//this.pendingTransactions.push(newTransaction);\n\t//return newTransaction;\n\tif(typeof(this.getLastBlock())=='undefined') {return 0;\n\t}else{\n\t\t//return this.getLastBlock()['index']+1;\n\t\treturn newTransaction;\n\t}\n\t//return newTransaction;\n};\n\nBlockchain.prototype.addTransactionToPendingTransactions = function(transactionObj) {\n\tthis.pendingTransactions.push(transactionObj);\n\treturn this.getLastBlock()['index'] + 1;\n};\n\n\nBlockchain.prototype.hashBlock = function(previousBlockHash, currentBlockData, nonce) {\n\tconst dataAsString = previousBlockHash + nonce.toString() + JSON.stringify(currentBlockData);\n\tconst hash = sha256(dataAsString);\n\treturn hash;\n};\n\n\nBlockchain.prototype.proofOfWork = function(previousBlockHash, currentBlockData) {\n\tlet nonce = 0;\n\tlet hash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\twhile (hash.substring(0, 6) !== '000000' && hash.substring(0, 6) !== '000001' &&\n\thash.substring(0, 6) !== '000002' && hash.substring(0, 6) !== '000003' &&\n\thash.substring(0, 6) !== '000004' &&\n\thash.substring(0, 6) !== '000005' &&\n\thash.substring(0, 6) !== '000006' &&\n\thash.substring(0, 6) !== '000007' &&\n\thash.substring(0, 6) !== '000008') {\n\t\tnonce++;\n\t\thash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\t}\n\tconsole.log('El nonce del pow es: ' +  hash , '..........', hash);\n\treturn nonce;\n};\n\n\nBlockchain.prototype.chainIsValid = function(blockchain) { //as a parameter a chain enter into this\n\t//function with the name blockchain\n\tlet validChain = true;\n\tfor (var i = 1; i < blockchain.length; i++) {\t\t\n\t\tconst prevBlock = blockchain[i - 1];\n\t\tconsole.log('previous block' + ' : ',prevBlock);\n\t\tconst currentBlock = blockchain[i];\n\t\tconsole.log('block' + i+1 + ' : ',currentBlock);\n\t\t//1. verify the hashes on every block by rehashing them and verifiying the amount of zeros.\n\t\t//const hash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\t\tlet currentBlockData = { transactions: currentBlock['transactions'], index: currentBlock['index'] };\n\t\tlet previousBlockHash = prevBlock['hash'];\n\t\tconst blockHash = this.hashBlock(previousBlockHash, currentBlockData,currentBlock['nonce']);\n\t\tconsole.log('blockHash',blockHash);\n\t\tif (blockHash.substring(0, 6) !== '000000' && blockHash.substring(0, 6) !== '000001' &&\n\t\tblockHash.substring(0, 6) !== '000002' && blockHash.substring(0, 6) !== '000003' &&\n\t\tblockHash.substring(0, 6) !== '000004' &&\n\t\tblockHash.substring(0, 6) !== '000005' &&\n\t\tblockHash.substring(0, 6) !== '000006' &&\n\t\tblockHash.substring(0, 6) !== '000007' &&\n\t\tblockHash.substring(0, 6) !== '000008' ) validChain = false;\n\t\tconsole.log('1. verify the hashes on every block by rehashing them and verifiying the amount of zeros: ',\n\t\tvalidChain);\n\t\t//2. verify the hash of the previous block hash on every current block\n\t\tif (currentBlock['previousBlockHash'] !== prevBlock['hash']) validChain = false;\n\t\tconsole.log('hash anterior',prevBlock['hash'],'previousBlockHash en current block',\n\t\tcurrentBlock['previousBlockHash'])\n\t\tconsole.log('2. verify the hash of the previous hash on every block: ', \n\t\tcurrentBlock['previousBlockHash'] == prevBlock['hash']);\n\t};\n\t//3. verify the initial values on the genesis block\n\tconst genesisBlock = blockchain[0];\n\tconst correctNonce = genesisBlock['nonce'] === 100;\n\tconst correctPreviousBlockHash = genesisBlock['previousBlockHash'] === '0';\n\tconst correctHash = genesisBlock['hash'] === '0';\n\tconst correctTransactions = genesisBlock['transactions'].length === 6;\n\n\tif (!correctNonce || !correctPreviousBlockHash || !correctHash || !correctTransactions) validChain = false;\n\tconsole.log('3. verify the initial values on the genesis block: ',\n\tcorrectNonce && correctPreviousBlockHash && correctHash && correctTransactions);\n\treturn validChain;\n};\n/*\n\nBlockchain.prototype.getBlock = function(blockHash) {\n\tlet correctBlock = null;\n\tthis.chain.forEach(block => {\n\t\tif (block.hash === blockHash) correctBlock = block;\n\t});\n\treturn correctBlock;\n};\n\n\nBlockchain.prototype.getTransaction = function(transactionId) {\n\tlet correctTransaction = null;\n\tlet correctBlock = null;\n\n\tthis.chain.forEach(block => {\n\t\tblock.transactions.forEach(transaction => {\n\t\t\tif (transaction.transactionId === transactionId) {\n\t\t\t\tcorrectTransaction = transaction;\n\t\t\t\tcorrectBlock = block;\n\t\t\t};\n\t\t});\n\t});\n\n\treturn {\n\t\ttransaction: correctTransaction,\n\t\tblock: correctBlock\n\t};\n};\n\n\nBlockchain.prototype.getAddressData = function(address) {\n\tconst addressTransactions = [];\n\tthis.chain.forEach(block => {\n\t\tblock.transactions.forEach(transaction => {\n\t\t\tif(transaction.sender === address || transaction.recipient === address) {\n\t\t\t\taddressTransactions.push(transaction);\n\t\t\t};\n\t\t});\n\t});\n\n\tlet balance = 0;\n\taddressTransactions.forEach(transaction => {\n\t\tif (transaction.recipient === address) balance += transaction.amount;\n\t\telse if (transaction.sender === address) balance -= transaction.amount;\n\t});\n\n\treturn {\n\t\taddressTransactions: addressTransactions,\n\t\taddressBalance: balance\n\t};\n};\n\n\n\n\n*/\n//module.exports = Blockchain;\n\n\nexport { Blockchain as default };","map":{"version":3,"sources":["/home/usuario1/Desktop/projects_P2P/webrtc_v6_sockets_pouch_3/webrtc/src/Blockchain/Blockchain.js"],"names":["v1","Blockchain","t","createFirstBlockHandler","tx","newTx","amount","sender","recipient","value4","value5","transactionId","split","join","pendingTransactions","push","createNewBlock","nonce","previousBlockHash","hash","newBlock","index","chain","length","timestamp","Date","now","transactions","getLastBlock"],"mappings":";AAAA;AACA;AACA;AACA,SAASA,EAAT,QAAmB,MAAnB;;IAEsBC,U,GAErB,oBAAYC,EAAZ,EAAe;AAAA;;AAAA;;AAAA,OAMZC,uBANY,GAMc,UAACD,CAAD,EAAM;AAClC;AADkC;AAAA;AAAA;;AAAA;AAE5B,2BAAeA,CAAf,8HAAiB;AAAA,YAARE,EAAQ;AACb,YAAMC,KAAK,GAAG;AACVC,UAAAA,MAAM,EAAEF,EAAE,CAACE,MADD;AAEVC,UAAAA,MAAM,EAAEH,EAAE,CAAC,QAAD,CAFA;AAGVI,UAAAA,SAAS,EAAEJ,EAAE,CAAC,WAAD,CAHH;AAIVK,UAAAA,MAAM,EAACL,EAAE,CAAC,QAAD,CAJC;AAKVM,UAAAA,MAAM,EAACN,EAAE,CAAC,QAAD,CALC;AAMVO,UAAAA,aAAa,EAAEX,EAAE,GAAGY,KAAL,CAAW,GAAX,EAAgBC,IAAhB,CAAqB,EAArB,CANL,CAM8B;AACxC;AAEb;;AATuB,SAAd;;AAUA,QAAA,KAAI,CAACC,mBAAL,CAAyBC,IAAzB,CAA8BV,KAA9B;AACT,OAdiC,CAelC;;AAfkC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgB5B,WAAO,KAAI,CAACW,cAAL,CAAoB,GAApB,EAAyB,GAAzB,EAA8B,GAA9B,CAAP;AAEH,GAxBW;;AAAA,OA0BZA,cA1BY,GA0BK,UAACC,KAAD,EAAQC,iBAAR,EAA2BC,IAA3B,EAAoC;AACjD,QAAMC,QAAQ,GAAG;AACbC,MAAAA,KAAK,EAAE,KAAI,CAACC,KAAL,CAAWC,MAAX,GAAoB,CADd;AAEbC,MAAAA,SAAS,EAAEC,IAAI,CAACC,GAAL,EAFE;AAGbC,MAAAA,YAAY,EAAE,KAAI,CAACb,mBAHN;AAIbG,MAAAA,KAAK,EAAEA,KAJM;AAKbE,MAAAA,IAAI,EAAEA,IALO;AAMbD,MAAAA,iBAAiB,EAAEA,iBANN,CASjB;;AATiB,KAAjB;AAUA,IAAA,KAAI,CAACJ,mBAAL,GAA2B,EAA3B;;AACN,IAAA,KAAI,CAACQ,KAAL,CAAWP,IAAX,CAAgBK,QAAhB,EAZuD,CAavD;;;AACM,WAAOA,QAAP;AACN,GAzCc;;AAAA,OA2CfQ,YA3Ce,GA2CA,YAAM;AACpB,WAAO,KAAI,CAACN,KAAL,CAAW,KAAI,CAACA,KAAL,CAAWC,MAAX,GAAoB,CAA/B,CAAP;AACA,GA7Cc;;AACd,OAAKD,KAAL,GAAa,EAAb;AACA,OAAKR,mBAAL,GAA2B,EAA3B;AACA,OAAKX,uBAAL,CAA6BD,EAA7B;AACA,C;AA2CF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4JA;;;SA7MsBD,U","sourcesContent":["//const sha256 = require('sha256');\n//import sha256 from 'sha256'\n//const currentNodeUrl = process.argv[3];//jalando la url contenida en el script cuando se inici esta\nimport { v1 } from 'uuid'\n\nexport default class  Blockchain { \n        \n\tconstructor(t) {\n\t\tthis.chain = []\n\t\tthis.pendingTransactions = []\n\t\tthis.createFirstBlockHandler(t)\t\t\n\t}\n    \n    createFirstBlockHandler = (t) =>{\n\t\t//console.log('recibido en createFirstBlockHandler:',t)\n        for (let tx of t){\n            const newTx = {\n                amount: tx.amount,\n                sender: tx['sender'],\n                recipient: tx['recipient'],\n                value4:tx['value4'],\n                value5:tx['value5'],\n                transactionId: v1().split('-').join('') //adding a new attribute, latter this must be\n                //sophisticated with cryptogtaphy.\n\t\t\t}\n\t\t\t//console.log(\"newTx\",newTx)\n            this.pendingTransactions.push(newTx)\n\t\t}\n\t\t//console.log('pending Transactions',this.pendingTransactions)\n        return this.createNewBlock(100, '0', '0')\n        \n    }\n\n    createNewBlock = (nonce, previousBlockHash, hash) => {\n        const newBlock = {\n            index: this.chain.length + 1,\n            timestamp: Date.now(),\n            transactions: this.pendingTransactions,\n            nonce: nonce,\n            hash: hash,\n            previousBlockHash: previousBlockHash\n        }\n        \n        //this.chain.push(newBlock);\n        this.pendingTransactions = []\n\t\tthis.chain.push(newBlock)\n\t\t//console.log(newBlock)\n        return newBlock;\n\t}\n\t\n\tgetLastBlock = () => {\n\t\treturn this.chain[this.chain.length - 1];\n\t}\n}\n/*\n\n\nBlockchain.prototype.createNewTransaction = function(amount, sender, recipient,value4,value5) {\n\tconst newTransaction = {\n\t\tamount: amount,\n\t\tsender: sender,\n\t\trecipient: recipient,\n\t\tvalue4:value4,\n\t\tvalue5:value5,\n\t\ttransactionId: uuid().split('-').join('') //adding a new attribute, latter this must be\n\t\t//sophisticated with cryptogtaphy.\n\t};\n\t//this.pendingTransactions.push(newTransaction);\n\t//return newTransaction;\n\tif(typeof(this.getLastBlock())=='undefined') {return 0;\n\t}else{\n\t\t//return this.getLastBlock()['index']+1;\n\t\treturn newTransaction;\n\t}\n\t//return newTransaction;\n};\n\nBlockchain.prototype.addTransactionToPendingTransactions = function(transactionObj) {\n\tthis.pendingTransactions.push(transactionObj);\n\treturn this.getLastBlock()['index'] + 1;\n};\n\n\nBlockchain.prototype.hashBlock = function(previousBlockHash, currentBlockData, nonce) {\n\tconst dataAsString = previousBlockHash + nonce.toString() + JSON.stringify(currentBlockData);\n\tconst hash = sha256(dataAsString);\n\treturn hash;\n};\n\n\nBlockchain.prototype.proofOfWork = function(previousBlockHash, currentBlockData) {\n\tlet nonce = 0;\n\tlet hash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\twhile (hash.substring(0, 6) !== '000000' && hash.substring(0, 6) !== '000001' &&\n\thash.substring(0, 6) !== '000002' && hash.substring(0, 6) !== '000003' &&\n\thash.substring(0, 6) !== '000004' &&\n\thash.substring(0, 6) !== '000005' &&\n\thash.substring(0, 6) !== '000006' &&\n\thash.substring(0, 6) !== '000007' &&\n\thash.substring(0, 6) !== '000008') {\n\t\tnonce++;\n\t\thash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\t}\n\tconsole.log('El nonce del pow es: ' +  hash , '..........', hash);\n\treturn nonce;\n};\n\n\nBlockchain.prototype.chainIsValid = function(blockchain) { //as a parameter a chain enter into this\n\t//function with the name blockchain\n\tlet validChain = true;\n\tfor (var i = 1; i < blockchain.length; i++) {\t\t\n\t\tconst prevBlock = blockchain[i - 1];\n\t\tconsole.log('previous block' + ' : ',prevBlock);\n\t\tconst currentBlock = blockchain[i];\n\t\tconsole.log('block' + i+1 + ' : ',currentBlock);\n\t\t//1. verify the hashes on every block by rehashing them and verifiying the amount of zeros.\n\t\t//const hash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\t\tlet currentBlockData = { transactions: currentBlock['transactions'], index: currentBlock['index'] };\n\t\tlet previousBlockHash = prevBlock['hash'];\n\t\tconst blockHash = this.hashBlock(previousBlockHash, currentBlockData,currentBlock['nonce']);\n\t\tconsole.log('blockHash',blockHash);\n\t\tif (blockHash.substring(0, 6) !== '000000' && blockHash.substring(0, 6) !== '000001' &&\n\t\tblockHash.substring(0, 6) !== '000002' && blockHash.substring(0, 6) !== '000003' &&\n\t\tblockHash.substring(0, 6) !== '000004' &&\n\t\tblockHash.substring(0, 6) !== '000005' &&\n\t\tblockHash.substring(0, 6) !== '000006' &&\n\t\tblockHash.substring(0, 6) !== '000007' &&\n\t\tblockHash.substring(0, 6) !== '000008' ) validChain = false;\n\t\tconsole.log('1. verify the hashes on every block by rehashing them and verifiying the amount of zeros: ',\n\t\tvalidChain);\n\t\t//2. verify the hash of the previous block hash on every current block\n\t\tif (currentBlock['previousBlockHash'] !== prevBlock['hash']) validChain = false;\n\t\tconsole.log('hash anterior',prevBlock['hash'],'previousBlockHash en current block',\n\t\tcurrentBlock['previousBlockHash'])\n\t\tconsole.log('2. verify the hash of the previous hash on every block: ', \n\t\tcurrentBlock['previousBlockHash'] == prevBlock['hash']);\n\t};\n\t//3. verify the initial values on the genesis block\n\tconst genesisBlock = blockchain[0];\n\tconst correctNonce = genesisBlock['nonce'] === 100;\n\tconst correctPreviousBlockHash = genesisBlock['previousBlockHash'] === '0';\n\tconst correctHash = genesisBlock['hash'] === '0';\n\tconst correctTransactions = genesisBlock['transactions'].length === 6;\n\n\tif (!correctNonce || !correctPreviousBlockHash || !correctHash || !correctTransactions) validChain = false;\n\tconsole.log('3. verify the initial values on the genesis block: ',\n\tcorrectNonce && correctPreviousBlockHash && correctHash && correctTransactions);\n\treturn validChain;\n};\n/*\n\nBlockchain.prototype.getBlock = function(blockHash) {\n\tlet correctBlock = null;\n\tthis.chain.forEach(block => {\n\t\tif (block.hash === blockHash) correctBlock = block;\n\t});\n\treturn correctBlock;\n};\n\n\nBlockchain.prototype.getTransaction = function(transactionId) {\n\tlet correctTransaction = null;\n\tlet correctBlock = null;\n\n\tthis.chain.forEach(block => {\n\t\tblock.transactions.forEach(transaction => {\n\t\t\tif (transaction.transactionId === transactionId) {\n\t\t\t\tcorrectTransaction = transaction;\n\t\t\t\tcorrectBlock = block;\n\t\t\t};\n\t\t});\n\t});\n\n\treturn {\n\t\ttransaction: correctTransaction,\n\t\tblock: correctBlock\n\t};\n};\n\n\nBlockchain.prototype.getAddressData = function(address) {\n\tconst addressTransactions = [];\n\tthis.chain.forEach(block => {\n\t\tblock.transactions.forEach(transaction => {\n\t\t\tif(transaction.sender === address || transaction.recipient === address) {\n\t\t\t\taddressTransactions.push(transaction);\n\t\t\t};\n\t\t});\n\t});\n\n\tlet balance = 0;\n\taddressTransactions.forEach(transaction => {\n\t\tif (transaction.recipient === address) balance += transaction.amount;\n\t\telse if (transaction.sender === address) balance -= transaction.amount;\n\t});\n\n\treturn {\n\t\taddressTransactions: addressTransactions,\n\t\taddressBalance: balance\n\t};\n};\n\n\n\n\n*/\n\n\n\n//module.exports = Blockchain;\n\n\n\n"]},"metadata":{},"sourceType":"module"}