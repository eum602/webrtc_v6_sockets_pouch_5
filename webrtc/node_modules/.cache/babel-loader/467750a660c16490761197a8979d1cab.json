{"ast":null,"code":"import _regeneratorRuntime from \"/home/usuario1/Desktop/projects_P2P/webrtc_v6_sockets_pouch_4/webrtc/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/usuario1/Desktop/projects_P2P/webrtc_v6_sockets_pouch_4/webrtc/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/home/usuario1/Desktop/projects_P2P/webrtc_v6_sockets_pouch_4/webrtc/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n//const sha256 = require('sha256');\n//import sha256 from 'sha256'\n//const currentNodeUrl = process.argv[3];//jalando la url contenida en el script cuando se inici esta\nimport PouchDB from 'pouchdb';\nimport { v1 } from 'uuid';\nimport PouchdbFind from 'pouchdb-find';\nimport DB from '../DB';\n\nvar Blockchain = function Blockchain() {\n  var _this = this;\n\n  _classCallCheck(this, Blockchain);\n\n  this.createFirstBlockHandler = function (t) {\n    //console.log('recibido en createFirstBlockHandler:',t)\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = t[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var tx = _step.value;\n        var newTx = {\n          amount: tx.amount,\n          sender: tx['sender'],\n          recipient: tx['recipient'],\n          value4: tx['value4'],\n          value5: tx['value5'],\n          transactionId: v1().split('-').join('') //adding a new attribute, latter this must be\n          //sophisticated with cryptogtaphy.\n          //console.log(\"newTx\",newTx)\n\n        };\n\n        _this.pendingTransactions.push(newTx);\n      } //console.log('pending Transactions',this.pendingTransactions)\n\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return _this.createNewBlock(100, '0', '0');\n  };\n\n  this.createNewBlock = function (nonce, previousBlockHash, hash) {\n    var newBlock = {\n      //_id: (this.chain.length + 1).toString(),\n      index: _this.chain.length + 1,\n      timestamp: Date.now(),\n      transactions: _this.pendingTransactions,\n      nonce: nonce,\n      hash: hash,\n      previousBlockHash: previousBlockHash //this.chain.push(newBlock);\n\n    };\n    _this.pendingTransactions = [];\n\n    _this.chain.push(newBlock); //console.log(newBlock)\n\n\n    return newBlock;\n  };\n\n  this.getLastBlock =\n  /*#__PURE__*/\n  _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee() {\n    var options, idx, key, foundBlock, rowIndex, aux;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = {\n              include_docs: true\n            };\n            idx = 0;\n            key = null;\n            foundBlock = null;\n            rowIndex = null;\n            aux = 0;\n            _context.next = 8;\n            return _this.db.allDocs(options, function (err, response) {\n              console.log(\"response\", response);\n\n              if (response && response.rows.length > 0) {\n                var fullBlocks = response.rows;\n                var _iteratorNormalCompletion2 = true;\n                var _didIteratorError2 = false;\n                var _iteratorError2 = undefined;\n\n                try {\n                  for (var _iterator2 = fullBlocks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var totalBlock = _step2.value;\n                    var block = totalBlock.doc;\n\n                    if (typeof block.index === \"number\") {\n                      if (block.index > idx) {\n                        idx = block.index;\n                        key = totalBlock.id;\n                        rowIndex = aux;\n                      }\n                    }\n\n                    aux++;\n                  }\n                } catch (err) {\n                  _didIteratorError2 = true;\n                  _iteratorError2 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                      _iterator2.return();\n                    }\n                  } finally {\n                    if (_didIteratorError2) {\n                      throw _iteratorError2;\n                    }\n                  }\n                }\n\n                console.log('lastBlock index found: ', idx);\n                console.log('id del bloque', key);\n                var _response$rows$rowInd = response['rows'][rowIndex]['doc'],\n                    index = _response$rows$rowInd.index,\n                    timestamp = _response$rows$rowInd.timestamp,\n                    transactions = _response$rows$rowInd.transactions,\n                    nonce = _response$rows$rowInd.nonce,\n                    hash = _response$rows$rowInd.hash,\n                    previousBlockHash = _response$rows$rowInd.previousBlockHash;\n                foundBlock = {\n                  index: index,\n                  timestamp: timestamp,\n                  transactions: transactions,\n                  nonce: nonce,\n                  hash: hash,\n                  previousBlockHash: previousBlockHash\n                };\n                console.log('las block from pouch...', foundBlock);\n              } else {\n                console.log('nothing received: ');\n              }\n\n              if (err) {\n                console.log('Error when getting las block...', err);\n              } // handle err or response\n\n            });\n\n          case 8:\n            return _context.abrupt(\"return\", foundBlock);\n\n          case 9:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n\n  this.createNewTransaction = function (newTx) {\n    var newTransaction = {\n      amount: newTx.amount,\n      sender: newTx.sender,\n      recipient: newTx.recipient,\n      value4: newTx.value4,\n      value5: newTx.value5,\n      transactionId: v1().split('-').join('') //adding a new attribute, latter this must be\n      //sophisticated with cryptogtaphy.\n      //this.pendingTransactions.push(newTransaction);\n      //return newTransaction;\t\t\n\n    };\n    var output = new Promise(function (resolve, reject) {\n      resolve(_this.getLastBlock());\n      reject('Error getting last Block');\n    }).then(function (block) {\n      if (block !== null) {\n        console.log('Allowed to create a transaction'); //return newTransaction\n\n        new Promise(function (resolve, reject) {\n          resolve(_this.addTransactionToPendingTransactions(newTransaction));\n          reject('Error adding a new Transation to the database');\n        });\n      }\n    }).then(function (res) {\n      return res;\n    });\n    return output;\n  };\n\n  this.addTransactionToPendingTransactions =\n  /*#__PURE__*/\n  function () {\n    var _ref2 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee2(newTx) {\n      var db1, res;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              //this.pendingTransactions.push(transactionObj)\n              db1 = new DB('blockchain');\n              _context2.next = 3;\n              return db1.saveTx(newTx);\n\n            case 3:\n              res = _context2.sent;\n\n              if (!(res !== null)) {\n                _context2.next = 7;\n                break;\n              }\n\n              console.log(\"Successfully saved Tx, pouch responded with: \".concat(res.toSring()));\n              return _context2.abrupt(\"return\", newTx);\n\n            case 7:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this);\n    }));\n\n    return function (_x) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  PouchDB.plugin(PouchdbFind);\n  this.chain = [];\n  this.pendingTransactions = [];\n  this.db = new PouchDB('blockchain');\n};\n/*\nBlockchain.prototype.hashBlock = function(previousBlockHash, currentBlockData, nonce) {\n\tconst dataAsString = previousBlockHash + nonce.toString() + JSON.stringify(currentBlockData);\n\tconst hash = sha256(dataAsString);\n\treturn hash;\n};\n\n\nBlockchain.prototype.proofOfWork = function(previousBlockHash, currentBlockData) {\n\tlet nonce = 0;\n\tlet hash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\twhile (hash.substring(0, 6) !== '000000' && hash.substring(0, 6) !== '000001' &&\n\thash.substring(0, 6) !== '000002' && hash.substring(0, 6) !== '000003' &&\n\thash.substring(0, 6) !== '000004' &&\n\thash.substring(0, 6) !== '000005' &&\n\thash.substring(0, 6) !== '000006' &&\n\thash.substring(0, 6) !== '000007' &&\n\thash.substring(0, 6) !== '000008') {\n\t\tnonce++;\n\t\thash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\t}\n\tconsole.log('El nonce del pow es: ' +  hash , '..........', hash);\n\treturn nonce;\n};\n\n\nBlockchain.prototype.chainIsValid = function(blockchain) { //as a parameter a chain enter into this\n\t//function with the name blockchain\n\tlet validChain = true;\n\tfor (var i = 1; i < blockchain.length; i++) {\t\t\n\t\tconst prevBlock = blockchain[i - 1];\n\t\tconsole.log('previous block' + ' : ',prevBlock);\n\t\tconst currentBlock = blockchain[i];\n\t\tconsole.log('block' + i+1 + ' : ',currentBlock);\n\t\t//1. verify the hashes on every block by rehashing them and verifiying the amount of zeros.\n\t\t//const hash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\t\tlet currentBlockData = { transactions: currentBlock['transactions'], index: currentBlock['index'] };\n\t\tlet previousBlockHash = prevBlock['hash'];\n\t\tconst blockHash = this.hashBlock(previousBlockHash, currentBlockData,currentBlock['nonce']);\n\t\tconsole.log('blockHash',blockHash);\n\t\tif (blockHash.substring(0, 6) !== '000000' && blockHash.substring(0, 6) !== '000001' &&\n\t\tblockHash.substring(0, 6) !== '000002' && blockHash.substring(0, 6) !== '000003' &&\n\t\tblockHash.substring(0, 6) !== '000004' &&\n\t\tblockHash.substring(0, 6) !== '000005' &&\n\t\tblockHash.substring(0, 6) !== '000006' &&\n\t\tblockHash.substring(0, 6) !== '000007' &&\n\t\tblockHash.substring(0, 6) !== '000008' ) validChain = false;\n\t\tconsole.log('1. verify the hashes on every block by rehashing them and verifiying the amount of zeros: ',\n\t\tvalidChain);\n\t\t//2. verify the hash of the previous block hash on every current block\n\t\tif (currentBlock['previousBlockHash'] !== prevBlock['hash']) validChain = false;\n\t\tconsole.log('hash anterior',prevBlock['hash'],'previousBlockHash en current block',\n\t\tcurrentBlock['previousBlockHash'])\n\t\tconsole.log('2. verify the hash of the previous hash on every block: ', \n\t\tcurrentBlock['previousBlockHash'] == prevBlock['hash']);\n\t};\n\t//3. verify the initial values on the genesis block\n\tconst genesisBlock = blockchain[0];\n\tconst correctNonce = genesisBlock['nonce'] === 100;\n\tconst correctPreviousBlockHash = genesisBlock['previousBlockHash'] === '0';\n\tconst correctHash = genesisBlock['hash'] === '0';\n\tconst correctTransactions = genesisBlock['transactions'].length === 6;\n\n\tif (!correctNonce || !correctPreviousBlockHash || !correctHash || !correctTransactions) validChain = false;\n\tconsole.log('3. verify the initial values on the genesis block: ',\n\tcorrectNonce && correctPreviousBlockHash && correctHash && correctTransactions);\n\treturn validChain;\n};\n/*\n\nBlockchain.prototype.getBlock = function(blockHash) {\n\tlet correctBlock = null;\n\tthis.chain.forEach(block => {\n\t\tif (block.hash === blockHash) correctBlock = block;\n\t});\n\treturn correctBlock;\n};\n\n\nBlockchain.prototype.getTransaction = function(transactionId) {\n\tlet correctTransaction = null;\n\tlet correctBlock = null;\n\n\tthis.chain.forEach(block => {\n\t\tblock.transactions.forEach(transaction => {\n\t\t\tif (transaction.transactionId === transactionId) {\n\t\t\t\tcorrectTransaction = transaction;\n\t\t\t\tcorrectBlock = block;\n\t\t\t};\n\t\t});\n\t});\n\n\treturn {\n\t\ttransaction: correctTransaction,\n\t\tblock: correctBlock\n\t};\n};\n\n\nBlockchain.prototype.getAddressData = function(address) {\n\tconst addressTransactions = [];\n\tthis.chain.forEach(block => {\n\t\tblock.transactions.forEach(transaction => {\n\t\t\tif(transaction.sender === address || transaction.recipient === address) {\n\t\t\t\taddressTransactions.push(transaction);\n\t\t\t};\n\t\t});\n\t});\n\n\tlet balance = 0;\n\taddressTransactions.forEach(transaction => {\n\t\tif (transaction.recipient === address) balance += transaction.amount;\n\t\telse if (transaction.sender === address) balance -= transaction.amount;\n\t});\n\n\treturn {\n\t\taddressTransactions: addressTransactions,\n\t\taddressBalance: balance\n\t};\n};\n\n\n\n\n*/\n//module.exports = Blockchain;\n\n\nexport { Blockchain as default };","map":{"version":3,"sources":["/home/usuario1/Desktop/projects_P2P/webrtc_v6_sockets_pouch_4/webrtc/src/Blockchain/Blockchain.js"],"names":["PouchDB","v1","PouchdbFind","DB","Blockchain","createFirstBlockHandler","t","tx","newTx","amount","sender","recipient","value4","value5","transactionId","split","join","pendingTransactions","push","createNewBlock","nonce","previousBlockHash","hash","newBlock","index","chain","length","timestamp","Date","now","transactions","getLastBlock","options","include_docs","idx","key","foundBlock","rowIndex","aux","db","allDocs","err","response","console","log","rows","fullBlocks","totalBlock","block","doc","id","createNewTransaction","newTransaction","output","Promise","resolve","reject","then","addTransactionToPendingTransactions","res","db1","saveTx","toSring","plugin"],"mappings":"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","sourcesContent":["//const sha256 = require('sha256');\n//import sha256 from 'sha256'\n//const currentNodeUrl = process.argv[3];//jalando la url contenida en el script cuando se inici esta\nimport PouchDB from 'pouchdb'\nimport { v1 } from 'uuid'\nimport PouchdbFind from 'pouchdb-find';\nimport DB from '../DB'\n\nexport default class  Blockchain { \n        \n\tconstructor() {\n\t\tPouchDB.plugin(PouchdbFind)\n\t\tthis.chain = []\n\t\tthis.pendingTransactions = []\n\t\tthis.db = new PouchDB('blockchain')\n\t}\n    \n    createFirstBlockHandler = (t) =>{\n\t\t//console.log('recibido en createFirstBlockHandler:',t)\n        for (let tx of t){\n            const newTx = {\n                amount: tx.amount,\n                sender: tx['sender'],\n                recipient: tx['recipient'],\n                value4:tx['value4'],\n                value5:tx['value5'],\n                transactionId: v1().split('-').join('') //adding a new attribute, latter this must be\n                //sophisticated with cryptogtaphy.\n\t\t\t}\n\t\t\t//console.log(\"newTx\",newTx)\n            this.pendingTransactions.push(newTx)\n\t\t}\n\t\t//console.log('pending Transactions',this.pendingTransactions)\n        return this.createNewBlock(100, '0', '0')\n        \n    }\n\n    createNewBlock = (nonce, previousBlockHash, hash) => {\n        const newBlock = {\n\t\t\t//_id: (this.chain.length + 1).toString(),\n            index: this.chain.length + 1,\n            timestamp: Date.now(),\n            transactions: this.pendingTransactions,\n            nonce: nonce,\n            hash: hash,\n            previousBlockHash: previousBlockHash\n        }\n        \n        //this.chain.push(newBlock);\n        this.pendingTransactions = []\n\t\tthis.chain.push(newBlock)\n\t\t//console.log(newBlock)\n        return newBlock;\n\t}\n\t\n\tgetLastBlock = async() => {\n\t\tlet options = {include_docs:true}\n\t\tlet idx = 0\n\t\tlet key = null\n\t\tlet foundBlock = null\n\t\tlet rowIndex = null\n\t\tlet aux = 0\n\t\t\n\t\tawait this.db.allDocs(options, (err, response) => {\n\t\t\tconsole.log(\"response\",response)\n\t\t\tif(response && response.rows.length > 0){\n\t\t\t\tlet fullBlocks = response.rows\n\t\t\t\tfor(let totalBlock of fullBlocks){\n\t\t\t\t\tlet block = totalBlock.doc\t\t\t\n\t\t\t\t\tif(typeof(block.index) === \"number\"){\n\t\t\t\t\t\tif(block.index > idx){\n\t\t\t\t\t\t\tidx = block.index\n\t\t\t\t\t\t\tkey = totalBlock.id\n\t\t\t\t\t\t\trowIndex = aux\n\t\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\taux++\n\t\t\t\t}\n\t\t\tconsole.log('lastBlock index found: ' , idx)\n\t\t\tconsole.log('id del bloque',key)\n\t\t\t\n\t\t\tconst {index,timestamp,transactions,nonce, hash , previousBlockHash} = \n\t\t\tresponse['rows'][rowIndex]['doc']\n\t\t\tfoundBlock = {index,timestamp,transactions,nonce, hash , previousBlockHash}\n\t\t\tconsole.log('las block from pouch...' , foundBlock)\n\t\t\t\n\t\t\t}else{\n\t\t\t\tconsole.log('nothing received: ')\n\t\t\t\t\n\t\t\t}\n\t\t\tif(err){\n\t\t\t\tconsole.log('Error when getting las block...',err)\n\t\t\t}\n\n\t\t\t// handle err or response\n\t\t})\n\t\treturn foundBlock\t\t\n\t}\n\n\tcreateNewTransaction = (newTx) => {\n\t\tconst newTransaction = {\n\t\t\tamount: newTx.amount,\n\t\t\tsender: newTx.sender,\n\t\t\trecipient: newTx.recipient,\n\t\t\tvalue4:newTx.value4,\n\t\t\tvalue5:newTx.value5,\n\t\t\ttransactionId: v1().split('-').join('') //adding a new attribute, latter this must be\n\t\t\t//sophisticated with cryptogtaphy.\n\t\t}\n\t\t//this.pendingTransactions.push(newTransaction);\n\t\t//return newTransaction;\t\t\n\t\tconst output = new Promise((resolve,reject)=>{\n\t\t\tresolve(this.getLastBlock())\n\t\t\treject('Error getting last Block')\n\t\t}).then(block=>{\n\t\t\tif(block !== null) {\n\t\t\t\tconsole.log('Allowed to create a transaction')\n\t\t\t\t//return newTransaction\n\t\t\t\tnew Promise((resolve,reject)=>{\n\t\t\t\t\tresolve(this.addTransactionToPendingTransactions(newTransaction))\n\t\t\t\t\treject('Error adding a new Transation to the database')\n\t\t\t\t})\n\t\t\t}\n\t\t}).then(res=>{\n\t\t\treturn res\n\t\t})\n\n\t\treturn output\n\t\t\n\t}\n\n\taddTransactionToPendingTransactions = async(newTx) => {\n\t\t//this.pendingTransactions.push(transactionObj)\n\t\tconst db1 = new DB('blockchain')\n\t\tconst res = await db1.saveTx(newTx)\n\t\tif(res !== null){\n\t\t\tconsole.log(`Successfully saved Tx, pouch responded with: ${res.toSring()}`)\n\t\t\treturn newTx\n\t\t}\n\t\t//return this.getLastBlock()['index'] + 1;\n\t}\n}\n\n/*\nBlockchain.prototype.hashBlock = function(previousBlockHash, currentBlockData, nonce) {\n\tconst dataAsString = previousBlockHash + nonce.toString() + JSON.stringify(currentBlockData);\n\tconst hash = sha256(dataAsString);\n\treturn hash;\n};\n\n\nBlockchain.prototype.proofOfWork = function(previousBlockHash, currentBlockData) {\n\tlet nonce = 0;\n\tlet hash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\twhile (hash.substring(0, 6) !== '000000' && hash.substring(0, 6) !== '000001' &&\n\thash.substring(0, 6) !== '000002' && hash.substring(0, 6) !== '000003' &&\n\thash.substring(0, 6) !== '000004' &&\n\thash.substring(0, 6) !== '000005' &&\n\thash.substring(0, 6) !== '000006' &&\n\thash.substring(0, 6) !== '000007' &&\n\thash.substring(0, 6) !== '000008') {\n\t\tnonce++;\n\t\thash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\t}\n\tconsole.log('El nonce del pow es: ' +  hash , '..........', hash);\n\treturn nonce;\n};\n\n\nBlockchain.prototype.chainIsValid = function(blockchain) { //as a parameter a chain enter into this\n\t//function with the name blockchain\n\tlet validChain = true;\n\tfor (var i = 1; i < blockchain.length; i++) {\t\t\n\t\tconst prevBlock = blockchain[i - 1];\n\t\tconsole.log('previous block' + ' : ',prevBlock);\n\t\tconst currentBlock = blockchain[i];\n\t\tconsole.log('block' + i+1 + ' : ',currentBlock);\n\t\t//1. verify the hashes on every block by rehashing them and verifiying the amount of zeros.\n\t\t//const hash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\t\tlet currentBlockData = { transactions: currentBlock['transactions'], index: currentBlock['index'] };\n\t\tlet previousBlockHash = prevBlock['hash'];\n\t\tconst blockHash = this.hashBlock(previousBlockHash, currentBlockData,currentBlock['nonce']);\n\t\tconsole.log('blockHash',blockHash);\n\t\tif (blockHash.substring(0, 6) !== '000000' && blockHash.substring(0, 6) !== '000001' &&\n\t\tblockHash.substring(0, 6) !== '000002' && blockHash.substring(0, 6) !== '000003' &&\n\t\tblockHash.substring(0, 6) !== '000004' &&\n\t\tblockHash.substring(0, 6) !== '000005' &&\n\t\tblockHash.substring(0, 6) !== '000006' &&\n\t\tblockHash.substring(0, 6) !== '000007' &&\n\t\tblockHash.substring(0, 6) !== '000008' ) validChain = false;\n\t\tconsole.log('1. verify the hashes on every block by rehashing them and verifiying the amount of zeros: ',\n\t\tvalidChain);\n\t\t//2. verify the hash of the previous block hash on every current block\n\t\tif (currentBlock['previousBlockHash'] !== prevBlock['hash']) validChain = false;\n\t\tconsole.log('hash anterior',prevBlock['hash'],'previousBlockHash en current block',\n\t\tcurrentBlock['previousBlockHash'])\n\t\tconsole.log('2. verify the hash of the previous hash on every block: ', \n\t\tcurrentBlock['previousBlockHash'] == prevBlock['hash']);\n\t};\n\t//3. verify the initial values on the genesis block\n\tconst genesisBlock = blockchain[0];\n\tconst correctNonce = genesisBlock['nonce'] === 100;\n\tconst correctPreviousBlockHash = genesisBlock['previousBlockHash'] === '0';\n\tconst correctHash = genesisBlock['hash'] === '0';\n\tconst correctTransactions = genesisBlock['transactions'].length === 6;\n\n\tif (!correctNonce || !correctPreviousBlockHash || !correctHash || !correctTransactions) validChain = false;\n\tconsole.log('3. verify the initial values on the genesis block: ',\n\tcorrectNonce && correctPreviousBlockHash && correctHash && correctTransactions);\n\treturn validChain;\n};\n/*\n\nBlockchain.prototype.getBlock = function(blockHash) {\n\tlet correctBlock = null;\n\tthis.chain.forEach(block => {\n\t\tif (block.hash === blockHash) correctBlock = block;\n\t});\n\treturn correctBlock;\n};\n\n\nBlockchain.prototype.getTransaction = function(transactionId) {\n\tlet correctTransaction = null;\n\tlet correctBlock = null;\n\n\tthis.chain.forEach(block => {\n\t\tblock.transactions.forEach(transaction => {\n\t\t\tif (transaction.transactionId === transactionId) {\n\t\t\t\tcorrectTransaction = transaction;\n\t\t\t\tcorrectBlock = block;\n\t\t\t};\n\t\t});\n\t});\n\n\treturn {\n\t\ttransaction: correctTransaction,\n\t\tblock: correctBlock\n\t};\n};\n\n\nBlockchain.prototype.getAddressData = function(address) {\n\tconst addressTransactions = [];\n\tthis.chain.forEach(block => {\n\t\tblock.transactions.forEach(transaction => {\n\t\t\tif(transaction.sender === address || transaction.recipient === address) {\n\t\t\t\taddressTransactions.push(transaction);\n\t\t\t};\n\t\t});\n\t});\n\n\tlet balance = 0;\n\taddressTransactions.forEach(transaction => {\n\t\tif (transaction.recipient === address) balance += transaction.amount;\n\t\telse if (transaction.sender === address) balance -= transaction.amount;\n\t});\n\n\treturn {\n\t\taddressTransactions: addressTransactions,\n\t\taddressBalance: balance\n\t};\n};\n\n\n\n\n*/\n\n\n\n//module.exports = Blockchain;\n\n\n\n"]},"metadata":{},"sourceType":"module"}