{"ast":null,"code":"import _regeneratorRuntime from \"/home/usuario1/Desktop/projects_P2P/webrtc_v6_sockets_pouch_3/webrtc/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/usuario1/Desktop/projects_P2P/webrtc_v6_sockets_pouch_3/webrtc/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/home/usuario1/Desktop/projects_P2P/webrtc_v6_sockets_pouch_3/webrtc/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n//const sha256 = require('sha256');\n//import sha256 from 'sha256'\n//const currentNodeUrl = process.argv[3];//jalando la url contenida en el script cuando se inici esta\nimport PouchDB from 'pouchdb';\nimport { v1 } from 'uuid';\nimport PouchdbFind from 'pouchdb-find';\n\nvar Blockchain = function Blockchain() {\n  var _this = this;\n\n  _classCallCheck(this, Blockchain);\n\n  this.createFirstBlockHandler = function (t) {\n    //console.log('recibido en createFirstBlockHandler:',t)\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = t[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var tx = _step.value;\n        var newTx = {\n          amount: tx.amount,\n          sender: tx['sender'],\n          recipient: tx['recipient'],\n          value4: tx['value4'],\n          value5: tx['value5'],\n          transactionId: v1().split('-').join('') //adding a new attribute, latter this must be\n          //sophisticated with cryptogtaphy.\n          //console.log(\"newTx\",newTx)\n\n        };\n\n        _this.pendingTransactions.push(newTx);\n      } //console.log('pending Transactions',this.pendingTransactions)\n\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return _this.createNewBlock(100, '0', '0');\n  };\n\n  this.createNewBlock = function (nonce, previousBlockHash, hash) {\n    var newBlock = {\n      //_id: (this.chain.length + 1).toString(),\n      index: _this.chain.length + 1,\n      timestamp: Date.now(),\n      transactions: _this.pendingTransactions,\n      nonce: nonce,\n      hash: hash,\n      previousBlockHash: previousBlockHash //this.chain.push(newBlock);\n\n    };\n    _this.pendingTransactions = [];\n\n    _this.chain.push(newBlock); //console.log(newBlock)\n\n\n    return newBlock;\n  };\n\n  this.getLastBlock =\n  /*#__PURE__*/\n  _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee() {\n    var options, idx, key, foundBlock;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = {\n              include_docs: true\n            };\n            idx = 0;\n            key = null;\n            foundBlock = null;\n\n            _this.db.allDocs(options, function (err, response) {\n              console.log(\"response\", response);\n\n              if (response && response.rows.length > 0) {\n                var fullBlocks = response.rows;\n                var _iteratorNormalCompletion2 = true;\n                var _didIteratorError2 = false;\n                var _iteratorError2 = undefined;\n\n                try {\n                  for (var _iterator2 = fullBlocks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var totalBlock = _step2.value;\n                    var block = totalBlock.doc;\n\n                    if (typeof block.index === \"number\") {\n                      if (block.index > idx) {\n                        idx = block.index;\n                        key = totalBlock.id;\n                      }\n                    }\n                  }\n                } catch (err) {\n                  _didIteratorError2 = true;\n                  _iteratorError2 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                      _iterator2.return();\n                    }\n                  } finally {\n                    if (_didIteratorError2) {\n                      throw _iteratorError2;\n                    }\n                  }\n                }\n\n                console.log('lastBlock index found: ', idx);\n                console.log('id del bloque', key);\n              } else {\n                console.log('nothing received: ');\n              }\n\n              if (err) {\n                console.log('Error when getting las block...', err);\n              }\n\n              return key; // handle err or response\n            }).then(function (key) {\n              console.log('received key: ', key);\n\n              _this.db.allDocs({\n                include_docs: true,\n                startkey: key,\n                limit: 1\n              }, function (err, res) {\n                var _res$rows$0$doc = res['rows'][0]['doc'],\n                    index = _res$rows$0$doc.index,\n                    timestamp = _res$rows$0$doc.timestamp,\n                    transactions = _res$rows$0$doc.transactions,\n                    nonce = _res$rows$0$doc.nonce,\n                    hash = _res$rows$0$doc.hash,\n                    previousBlockHash = _res$rows$0$doc.previousBlockHash;\n                foundBlock = {\n                  index: index,\n                  timestamp: timestamp,\n                  transactions: transactions,\n                  nonce: nonce,\n                  hash: hash,\n                  previousBlockHash: previousBlockHash\n                };\n                console.log('las block from pouch...', foundBlock);\n              });\n            });\n\n            return _context.abrupt(\"return\", foundBlock);\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n  PouchDB.plugin(PouchdbFind);\n  this.chain = [];\n  this.pendingTransactions = [];\n  this.db = new PouchDB('blockchain');\n};\n/*\n\n\nBlockchain.prototype.createNewTransaction = function(amount, sender, recipient,value4,value5) {\n\tconst newTransaction = {\n\t\tamount: amount,\n\t\tsender: sender,\n\t\trecipient: recipient,\n\t\tvalue4:value4,\n\t\tvalue5:value5,\n\t\ttransactionId: uuid().split('-').join('') //adding a new attribute, latter this must be\n\t\t//sophisticated with cryptogtaphy.\n\t};\n\t//this.pendingTransactions.push(newTransaction);\n\t//return newTransaction;\n\tif(typeof(this.getLastBlock())=='undefined') {return 0;\n\t}else{\n\t\t//return this.getLastBlock()['index']+1;\n\t\treturn newTransaction;\n\t}\n\t//return newTransaction;\n};\n\nBlockchain.prototype.addTransactionToPendingTransactions = function(transactionObj) {\n\tthis.pendingTransactions.push(transactionObj);\n\treturn this.getLastBlock()['index'] + 1;\n};\n\n\nBlockchain.prototype.hashBlock = function(previousBlockHash, currentBlockData, nonce) {\n\tconst dataAsString = previousBlockHash + nonce.toString() + JSON.stringify(currentBlockData);\n\tconst hash = sha256(dataAsString);\n\treturn hash;\n};\n\n\nBlockchain.prototype.proofOfWork = function(previousBlockHash, currentBlockData) {\n\tlet nonce = 0;\n\tlet hash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\twhile (hash.substring(0, 6) !== '000000' && hash.substring(0, 6) !== '000001' &&\n\thash.substring(0, 6) !== '000002' && hash.substring(0, 6) !== '000003' &&\n\thash.substring(0, 6) !== '000004' &&\n\thash.substring(0, 6) !== '000005' &&\n\thash.substring(0, 6) !== '000006' &&\n\thash.substring(0, 6) !== '000007' &&\n\thash.substring(0, 6) !== '000008') {\n\t\tnonce++;\n\t\thash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\t}\n\tconsole.log('El nonce del pow es: ' +  hash , '..........', hash);\n\treturn nonce;\n};\n\n\nBlockchain.prototype.chainIsValid = function(blockchain) { //as a parameter a chain enter into this\n\t//function with the name blockchain\n\tlet validChain = true;\n\tfor (var i = 1; i < blockchain.length; i++) {\t\t\n\t\tconst prevBlock = blockchain[i - 1];\n\t\tconsole.log('previous block' + ' : ',prevBlock);\n\t\tconst currentBlock = blockchain[i];\n\t\tconsole.log('block' + i+1 + ' : ',currentBlock);\n\t\t//1. verify the hashes on every block by rehashing them and verifiying the amount of zeros.\n\t\t//const hash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\t\tlet currentBlockData = { transactions: currentBlock['transactions'], index: currentBlock['index'] };\n\t\tlet previousBlockHash = prevBlock['hash'];\n\t\tconst blockHash = this.hashBlock(previousBlockHash, currentBlockData,currentBlock['nonce']);\n\t\tconsole.log('blockHash',blockHash);\n\t\tif (blockHash.substring(0, 6) !== '000000' && blockHash.substring(0, 6) !== '000001' &&\n\t\tblockHash.substring(0, 6) !== '000002' && blockHash.substring(0, 6) !== '000003' &&\n\t\tblockHash.substring(0, 6) !== '000004' &&\n\t\tblockHash.substring(0, 6) !== '000005' &&\n\t\tblockHash.substring(0, 6) !== '000006' &&\n\t\tblockHash.substring(0, 6) !== '000007' &&\n\t\tblockHash.substring(0, 6) !== '000008' ) validChain = false;\n\t\tconsole.log('1. verify the hashes on every block by rehashing them and verifiying the amount of zeros: ',\n\t\tvalidChain);\n\t\t//2. verify the hash of the previous block hash on every current block\n\t\tif (currentBlock['previousBlockHash'] !== prevBlock['hash']) validChain = false;\n\t\tconsole.log('hash anterior',prevBlock['hash'],'previousBlockHash en current block',\n\t\tcurrentBlock['previousBlockHash'])\n\t\tconsole.log('2. verify the hash of the previous hash on every block: ', \n\t\tcurrentBlock['previousBlockHash'] == prevBlock['hash']);\n\t};\n\t//3. verify the initial values on the genesis block\n\tconst genesisBlock = blockchain[0];\n\tconst correctNonce = genesisBlock['nonce'] === 100;\n\tconst correctPreviousBlockHash = genesisBlock['previousBlockHash'] === '0';\n\tconst correctHash = genesisBlock['hash'] === '0';\n\tconst correctTransactions = genesisBlock['transactions'].length === 6;\n\n\tif (!correctNonce || !correctPreviousBlockHash || !correctHash || !correctTransactions) validChain = false;\n\tconsole.log('3. verify the initial values on the genesis block: ',\n\tcorrectNonce && correctPreviousBlockHash && correctHash && correctTransactions);\n\treturn validChain;\n};\n/*\n\nBlockchain.prototype.getBlock = function(blockHash) {\n\tlet correctBlock = null;\n\tthis.chain.forEach(block => {\n\t\tif (block.hash === blockHash) correctBlock = block;\n\t});\n\treturn correctBlock;\n};\n\n\nBlockchain.prototype.getTransaction = function(transactionId) {\n\tlet correctTransaction = null;\n\tlet correctBlock = null;\n\n\tthis.chain.forEach(block => {\n\t\tblock.transactions.forEach(transaction => {\n\t\t\tif (transaction.transactionId === transactionId) {\n\t\t\t\tcorrectTransaction = transaction;\n\t\t\t\tcorrectBlock = block;\n\t\t\t};\n\t\t});\n\t});\n\n\treturn {\n\t\ttransaction: correctTransaction,\n\t\tblock: correctBlock\n\t};\n};\n\n\nBlockchain.prototype.getAddressData = function(address) {\n\tconst addressTransactions = [];\n\tthis.chain.forEach(block => {\n\t\tblock.transactions.forEach(transaction => {\n\t\t\tif(transaction.sender === address || transaction.recipient === address) {\n\t\t\t\taddressTransactions.push(transaction);\n\t\t\t};\n\t\t});\n\t});\n\n\tlet balance = 0;\n\taddressTransactions.forEach(transaction => {\n\t\tif (transaction.recipient === address) balance += transaction.amount;\n\t\telse if (transaction.sender === address) balance -= transaction.amount;\n\t});\n\n\treturn {\n\t\taddressTransactions: addressTransactions,\n\t\taddressBalance: balance\n\t};\n};\n\n\n\n\n*/\n//module.exports = Blockchain;\n\n\nexport { Blockchain as default };","map":{"version":3,"sources":["/home/usuario1/Desktop/projects_P2P/webrtc_v6_sockets_pouch_3/webrtc/src/Blockchain/Blockchain.js"],"names":["PouchDB","v1","PouchdbFind","Blockchain","createFirstBlockHandler","t","tx","newTx","amount","sender","recipient","value4","value5","transactionId","split","join","pendingTransactions","push","createNewBlock","nonce","previousBlockHash","hash","newBlock","index","chain","length","timestamp","Date","now","transactions","getLastBlock","options","include_docs","idx","key","foundBlock","db","allDocs","err","response","console","log","rows","fullBlocks","totalBlock","block","doc","id","then","startkey","limit","res","plugin"],"mappings":"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","sourcesContent":["//const sha256 = require('sha256');\n//import sha256 from 'sha256'\n//const currentNodeUrl = process.argv[3];//jalando la url contenida en el script cuando se inici esta\nimport PouchDB from 'pouchdb'\nimport { v1 } from 'uuid'\nimport PouchdbFind from 'pouchdb-find';\n\nexport default class  Blockchain { \n        \n\tconstructor() {\n\t\tPouchDB.plugin(PouchdbFind)\n\t\tthis.chain = []\n\t\tthis.pendingTransactions = []\n\t\tthis.db = new PouchDB('blockchain')\n\t}\n    \n    createFirstBlockHandler = (t) =>{\n\t\t//console.log('recibido en createFirstBlockHandler:',t)\n        for (let tx of t){\n            const newTx = {\n                amount: tx.amount,\n                sender: tx['sender'],\n                recipient: tx['recipient'],\n                value4:tx['value4'],\n                value5:tx['value5'],\n                transactionId: v1().split('-').join('') //adding a new attribute, latter this must be\n                //sophisticated with cryptogtaphy.\n\t\t\t}\n\t\t\t//console.log(\"newTx\",newTx)\n            this.pendingTransactions.push(newTx)\n\t\t}\n\t\t//console.log('pending Transactions',this.pendingTransactions)\n        return this.createNewBlock(100, '0', '0')\n        \n    }\n\n    createNewBlock = (nonce, previousBlockHash, hash) => {\n        const newBlock = {\n\t\t\t//_id: (this.chain.length + 1).toString(),\n            index: this.chain.length + 1,\n            timestamp: Date.now(),\n            transactions: this.pendingTransactions,\n            nonce: nonce,\n            hash: hash,\n            previousBlockHash: previousBlockHash\n        }\n        \n        //this.chain.push(newBlock);\n        this.pendingTransactions = []\n\t\tthis.chain.push(newBlock)\n\t\t//console.log(newBlock)\n        return newBlock;\n\t}\n\t\n\tgetLastBlock = async() => {\n\t\tlet options = {include_docs:true}\n\t\tlet idx = 0\n\t\tlet key = null\n\t\tlet foundBlock = null\n\t\t\n\t\tthis.db.allDocs(options, (err, response) => {\n\t\t\tconsole.log(\"response\",response)\n\t\t\tif(response && response.rows.length > 0){\n\t\t\t\tlet fullBlocks = response.rows\n\t\t\t\tfor(let totalBlock of fullBlocks){\n\t\t\t\t\tlet block = totalBlock.doc\t\t\t\t\n\t\t\t\t\tif(typeof(block.index) === \"number\"){\n\t\t\t\t\t\tif(block.index > idx){\n\t\t\t\t\t\t\tidx = block.index\n\t\t\t\t\t\t\tkey = totalBlock.id\n\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tconsole.log('lastBlock index found: ' , idx)\n\t\t\tconsole.log('id del bloque',key)\n\t\t\t\t\n\t\t\t}else{\n\t\t\t\tconsole.log('nothing received: ')\n\t\t\t\t\n\t\t\t}\n\t\t\tif(err){\n\t\t\t\tconsole.log('Error when getting las block...',err)\n\t\t\t}\n\n\t\t\treturn key\n\n\t\t\t// handle err or response\n\t\t}).then(key=>{\n\t\t\tconsole.log('received key: ', key)\n\t\t\tthis.db.allDocs({include_docs:true,startkey:key,limit:1},(err,res)=>{\n\t\t\t\tconst {index,timestamp,transactions,nonce, hash , previousBlockHash} = res['rows'][0]['doc']\n\t\t\t\tfoundBlock = {index,timestamp,transactions,nonce, hash , previousBlockHash}\n\t\t\t\tconsole.log('las block from pouch...' , foundBlock)\t\t\t\t\n\t\t\t})\n\t\t})\n\t\treturn foundBlock\n\t\t\n\t\t\n\t\t/*\n\t\tconsole.log('Entering to get Last Block...')\n\t\tlet idx\n\t\tlet options = {limit:1,include_docs:true}//by default descending false\n\t\tlet k = 0\n\t\twhile(typeof(options.startKey)===undefined){\n\t\t\tk++\n\t\t\tconsole.log(`${k}. Finding the las block...`)\n\t\t\tawait this.db.allDocs(options,(err,res)=>{\n\t\t\t\tif(res && res.rows.length > 0){\n\t\t\t\t\tif(res['rows'][0]['doc'].index){\n\t\t\t\t\t\tidx = res['rows'][0]['doc'].index\n\t\t\t\t\t}else{\n\t\t\t\t\t\toptions.skip = k\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\tconsole.log(idx)\n\t\n\t\n\t\t\treturn idx\n\t\t}\n\t\t\n\t\t\n\t\t/*\n\t\tlet block\n\t\tawait this.db.allDocs({include_docs : true,limit:1},(err,res)=>{\n\t\t\tconsole.log('retrieving last document:', res)\n\t\t\tconst {index,timestamp,transactions,nonce, hash , previousBlockHash} = res['rows'][0]['doc']\n\t\t\tblock = {index,timestamp,transactions,nonce, hash , previousBlockHash}\t\t\t\t\t\t\n\t\t})\n\t\tconsole.log('las block from pouch...' , block)\n\t\treturn block\n\t\t\n\n\t\t/*\n\t\tnew Promise((resolve, reject)=>{\n\t\t\tresolve(this.db.createIndex({index:{fields:[\"index\"]}}))\n\t\t\treject('Error creatingIndex')\n\t\t}).then(results=>{\n\t\t\tconsole.log(\"results de CreateIndex: \", results )\n\t\t\tnew Promise((resolve,reject)=>{\n\t\t\t\tresolve(this.db.find({\n\t\t\t\t\tselector:{\n\t\t\t\t\t\tindex: \"0\"//{$eq:0}\n\t\t\t\t\t}\n\t\t\t\t}))\n\t\t\t\treject('Error when getting with find...')\n\t\t\t})\n\t\t}).then(r=>{\n\t\t\tconsole.log('resultados de la busqueda: ', r)\n\t\t})\n\t\t\n\t\tlet promise = this.db.createIndex({\n\t\t\tindex:{\n\t\t\t\tfields:[\"index\"]\n\t\t\t}\n\t\t})\n\n\t\tpromise.then(results =>{\n\t\t\tconsole.log(\"results de CreateIndex: \", results )\n\t\t})\n\n\t\tlet promise1 = this.db.find({\n\t\t\tselector:{\n\t\t\t\tindex: 0//{$eq:0}\n\t\t\t}\n\t\t})\n\t\t\n\t\tpromise1.then((results=>{\n\t\t\tconsole.log('results: ',results)\n\t\t}))*/\n\n\t\t//return this.chain[this.chain.length - 1];\n\t}\n}\n/*\n\n\nBlockchain.prototype.createNewTransaction = function(amount, sender, recipient,value4,value5) {\n\tconst newTransaction = {\n\t\tamount: amount,\n\t\tsender: sender,\n\t\trecipient: recipient,\n\t\tvalue4:value4,\n\t\tvalue5:value5,\n\t\ttransactionId: uuid().split('-').join('') //adding a new attribute, latter this must be\n\t\t//sophisticated with cryptogtaphy.\n\t};\n\t//this.pendingTransactions.push(newTransaction);\n\t//return newTransaction;\n\tif(typeof(this.getLastBlock())=='undefined') {return 0;\n\t}else{\n\t\t//return this.getLastBlock()['index']+1;\n\t\treturn newTransaction;\n\t}\n\t//return newTransaction;\n};\n\nBlockchain.prototype.addTransactionToPendingTransactions = function(transactionObj) {\n\tthis.pendingTransactions.push(transactionObj);\n\treturn this.getLastBlock()['index'] + 1;\n};\n\n\nBlockchain.prototype.hashBlock = function(previousBlockHash, currentBlockData, nonce) {\n\tconst dataAsString = previousBlockHash + nonce.toString() + JSON.stringify(currentBlockData);\n\tconst hash = sha256(dataAsString);\n\treturn hash;\n};\n\n\nBlockchain.prototype.proofOfWork = function(previousBlockHash, currentBlockData) {\n\tlet nonce = 0;\n\tlet hash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\twhile (hash.substring(0, 6) !== '000000' && hash.substring(0, 6) !== '000001' &&\n\thash.substring(0, 6) !== '000002' && hash.substring(0, 6) !== '000003' &&\n\thash.substring(0, 6) !== '000004' &&\n\thash.substring(0, 6) !== '000005' &&\n\thash.substring(0, 6) !== '000006' &&\n\thash.substring(0, 6) !== '000007' &&\n\thash.substring(0, 6) !== '000008') {\n\t\tnonce++;\n\t\thash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\t}\n\tconsole.log('El nonce del pow es: ' +  hash , '..........', hash);\n\treturn nonce;\n};\n\n\nBlockchain.prototype.chainIsValid = function(blockchain) { //as a parameter a chain enter into this\n\t//function with the name blockchain\n\tlet validChain = true;\n\tfor (var i = 1; i < blockchain.length; i++) {\t\t\n\t\tconst prevBlock = blockchain[i - 1];\n\t\tconsole.log('previous block' + ' : ',prevBlock);\n\t\tconst currentBlock = blockchain[i];\n\t\tconsole.log('block' + i+1 + ' : ',currentBlock);\n\t\t//1. verify the hashes on every block by rehashing them and verifiying the amount of zeros.\n\t\t//const hash = this.hashBlock(previousBlockHash, currentBlockData, nonce);\n\t\tlet currentBlockData = { transactions: currentBlock['transactions'], index: currentBlock['index'] };\n\t\tlet previousBlockHash = prevBlock['hash'];\n\t\tconst blockHash = this.hashBlock(previousBlockHash, currentBlockData,currentBlock['nonce']);\n\t\tconsole.log('blockHash',blockHash);\n\t\tif (blockHash.substring(0, 6) !== '000000' && blockHash.substring(0, 6) !== '000001' &&\n\t\tblockHash.substring(0, 6) !== '000002' && blockHash.substring(0, 6) !== '000003' &&\n\t\tblockHash.substring(0, 6) !== '000004' &&\n\t\tblockHash.substring(0, 6) !== '000005' &&\n\t\tblockHash.substring(0, 6) !== '000006' &&\n\t\tblockHash.substring(0, 6) !== '000007' &&\n\t\tblockHash.substring(0, 6) !== '000008' ) validChain = false;\n\t\tconsole.log('1. verify the hashes on every block by rehashing them and verifiying the amount of zeros: ',\n\t\tvalidChain);\n\t\t//2. verify the hash of the previous block hash on every current block\n\t\tif (currentBlock['previousBlockHash'] !== prevBlock['hash']) validChain = false;\n\t\tconsole.log('hash anterior',prevBlock['hash'],'previousBlockHash en current block',\n\t\tcurrentBlock['previousBlockHash'])\n\t\tconsole.log('2. verify the hash of the previous hash on every block: ', \n\t\tcurrentBlock['previousBlockHash'] == prevBlock['hash']);\n\t};\n\t//3. verify the initial values on the genesis block\n\tconst genesisBlock = blockchain[0];\n\tconst correctNonce = genesisBlock['nonce'] === 100;\n\tconst correctPreviousBlockHash = genesisBlock['previousBlockHash'] === '0';\n\tconst correctHash = genesisBlock['hash'] === '0';\n\tconst correctTransactions = genesisBlock['transactions'].length === 6;\n\n\tif (!correctNonce || !correctPreviousBlockHash || !correctHash || !correctTransactions) validChain = false;\n\tconsole.log('3. verify the initial values on the genesis block: ',\n\tcorrectNonce && correctPreviousBlockHash && correctHash && correctTransactions);\n\treturn validChain;\n};\n/*\n\nBlockchain.prototype.getBlock = function(blockHash) {\n\tlet correctBlock = null;\n\tthis.chain.forEach(block => {\n\t\tif (block.hash === blockHash) correctBlock = block;\n\t});\n\treturn correctBlock;\n};\n\n\nBlockchain.prototype.getTransaction = function(transactionId) {\n\tlet correctTransaction = null;\n\tlet correctBlock = null;\n\n\tthis.chain.forEach(block => {\n\t\tblock.transactions.forEach(transaction => {\n\t\t\tif (transaction.transactionId === transactionId) {\n\t\t\t\tcorrectTransaction = transaction;\n\t\t\t\tcorrectBlock = block;\n\t\t\t};\n\t\t});\n\t});\n\n\treturn {\n\t\ttransaction: correctTransaction,\n\t\tblock: correctBlock\n\t};\n};\n\n\nBlockchain.prototype.getAddressData = function(address) {\n\tconst addressTransactions = [];\n\tthis.chain.forEach(block => {\n\t\tblock.transactions.forEach(transaction => {\n\t\t\tif(transaction.sender === address || transaction.recipient === address) {\n\t\t\t\taddressTransactions.push(transaction);\n\t\t\t};\n\t\t});\n\t});\n\n\tlet balance = 0;\n\taddressTransactions.forEach(transaction => {\n\t\tif (transaction.recipient === address) balance += transaction.amount;\n\t\telse if (transaction.sender === address) balance -= transaction.amount;\n\t});\n\n\treturn {\n\t\taddressTransactions: addressTransactions,\n\t\taddressBalance: balance\n\t};\n};\n\n\n\n\n*/\n\n\n\n//module.exports = Blockchain;\n\n\n\n"]},"metadata":{},"sourceType":"module"}