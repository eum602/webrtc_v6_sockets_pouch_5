{"ast":null,"code":"import _toConsumableArray from \"/home/usuario1/Desktop/projects_P2P/webrtc_v6_sockets_pouch_2/webrtc/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/usuario1/Desktop/projects_P2P/webrtc_v6_sockets_pouch_2/webrtc/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/usuario1/Desktop/projects_P2P/webrtc_v6_sockets_pouch_2/webrtc/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/home/usuario1/Desktop/projects_P2P/webrtc_v6_sockets_pouch_2/webrtc/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _inherits from \"/home/usuario1/Desktop/projects_P2P/webrtc_v6_sockets_pouch_2/webrtc/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/home/usuario1/Desktop/projects_P2P/webrtc_v6_sockets_pouch_2/webrtc/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport React, { Component } from 'react';\n\nvar NewPeer =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(NewPeer, _Component);\n\n  function NewPeer(props) {\n    var _this;\n\n    _classCallCheck(this, NewPeer);\n\n    var _rtcPeerConn = props.rtcPeerConn;\n    var _sendDataChannel = props.sendDataChannel;\n    var _catchDataChannel = props.catchDataChannel;\n    _this.callAction = _this.callAction.bind(_assertThisInitialized(_assertThisInitialized(_this)), _rtcPeerConn, _sendDataChannel, _catchDataChannel);\n    _this.state = {\n      fileBuffer: [],\n      fileSize: [],\n      icesReq: []\n    };\n    return _possibleConstructorReturn(_this);\n  }\n\n  _createClass(NewPeer, [{\n    key: \"dataChannelStateChanged\",\n    value: function dataChannelStateChanged(e, i, catchDataChannel) {\n      if (catchDataChannel[i].readyState === 'open') {\n        //si el readyState es abierto\n        //displaySignalMessage(\"Data Channel Opened\")\n        console.log(\"Data Channel Opened\");\n      } else {\n        //displaySignalMessage(\"data channel is : \" + catchDataChannel[i].readyState)\n        console.log(\"data channel is : \" + catchDataChannel[i].readyState);\n      }\n    }\n  }, {\n    key: \"handleConnection\",\n    value: function handleConnection(event) {\n      var iceCandidate = event.candidate;\n\n      if (iceCandidate) {\n        var icesReq = this.state.icesReq;\n        icesReq.push(iceCandidate);\n        this.setState({\n          icesReq: icesReq\n        });\n      } else if (!iceCandidate && this.state.icesReq.length > 0) {\n        var socket = this.props.socket;\n        var len = this.state.icesReq.length;\n        var iter = 0; //displaySignalMessage(\"ICE protocol gathered \" + len + \" candidates..\" )\n\n        console.log(\"ICE protocol gathered \" + len + \" candidates..\");\n        var newIceCandidate;\n\n        var _icesReq = _toConsumableArray(this.state.icesReq);\n\n        _icesReq.forEach(function (iceCandidate) {\n          iter++;\n          newIceCandidate = iceCandidate;\n          console.log(\"candidate created ready to be sent: \", newIceCandidate);\n          socket.emit('signal', {\n            \"type\": \"ice candidate\",\n            \"message\": JSON.stringify({\n              'candidate': newIceCandidate\n            }) //\"room\":SIGNAL_ROOM\n\n          }); //displaySignalMessage( iter +\". Sending Ice candidate ...\");\n\n          console.log(iter + \". Sending Ice candidate ...\");\n        });\n\n        socket.emit('signal', {\n          \"type\": \"noIce\",\n          \"message\": \"\" //\"room\":SIGNAL_ROOM})\n\n        }); //icesReq = []\n      } else if (!iceCandidate && this.state.icesReq.length == 0) {\n        //displaySignalMessage(\"Candidate received is null, no candidates received yet, check your code!..\")\n        console.log(\"Candidate received is null, no candidates received yet, check your code!..\");\n      }\n    }\n  }]);\n\n  return NewPeer;\n}(Component);\n\nexport { NewPeer as default };","map":{"version":3,"sources":["/home/usuario1/Desktop/projects_P2P/webrtc_v6_sockets_pouch_2/webrtc/src/wrtconf/NewPeer.js"],"names":["React","Component","NewPeer","props","rtcPeerConn","sendDataChannel","catchDataChannel","callAction","bind","state","fileBuffer","fileSize","icesReq","e","i","readyState","console","log","event","iceCandidate","candidate","push","setState","length","socket","len","iter","newIceCandidate","forEach","emit","JSON","stringify"],"mappings":";;;;;;AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAgC,OAAhC;;IAEqBC,O;;;;;AAEjB,mBAAaC,KAAb,EAAoB;AAAA;;AAAA;;AAChB,QAAIC,YAAW,GAAGD,KAAK,CAACC,WAAxB;AACA,QAAIC,gBAAe,GAAGF,KAAK,CAACE,eAA5B;AACA,QAAIC,iBAAgB,GAAGH,KAAK,CAACG,gBAA7B;AACA,UAAKC,UAAL,GAAkB,MAAKA,UAAL,CAAgBC,IAAhB,wDAA0BJ,YAA1B,EAAsCC,gBAAtC,EAAsDC,iBAAtD,CAAlB;AACA,UAAKG,KAAL,GAAa;AACTC,MAAAA,UAAU,EAAG,EADJ;AAETC,MAAAA,QAAQ,EAAG,EAFF;AAGTC,MAAAA,OAAO,EAAG;AAHD,KAAb;AALgB;AAUnB;;;;4CA4FuBC,C,EAAEC,C,EAAER,gB,EAAiB;AACzC,UAAGA,gBAAgB,CAACQ,CAAD,CAAhB,CAAoBC,UAApB,KAAmC,MAAtC,EAA6C;AAAC;AAC1C;AACAC,QAAAA,OAAO,CAACC,GAAR,CAAY,qBAAZ;AACH,OAHD,MAGK;AACD;AACAD,QAAAA,OAAO,CAACC,GAAR,CAAY,uBAAuBX,gBAAgB,CAACQ,CAAD,CAAhB,CAAoBC,UAAvD;AACH;AACJ;;;qCAEgBG,K,EAAO;AACpB,UAAMC,YAAY,GAAGD,KAAK,CAACE,SAA3B;;AACA,UAAGD,YAAH,EAAgB;AACZ,YAAIP,OAAO,GAAG,KAAKH,KAAL,CAAWG,OAAzB;AACAA,QAAAA,OAAO,CAACS,IAAR,CAAaF,YAAb;AACA,aAAKG,QAAL,CAAc;AAACV,UAAAA,OAAO,EAAPA;AAAD,SAAd;AACH,OAJD,MAKK,IAAI,CAACO,YAAD,IAAiB,KAAKV,KAAL,CAAWG,OAAX,CAAmBW,MAAnB,GAA0B,CAA/C,EAAkD;AAAA,YAC5CC,MAD4C,GAClC,KAAKrB,KAD6B,CAC5CqB,MAD4C;AAEnD,YAAIC,GAAG,GAAG,KAAKhB,KAAL,CAAWG,OAAX,CAAmBW,MAA7B;AACA,YAAIG,IAAI,GAAG,CAAX,CAHmD,CAInD;;AACAV,QAAAA,OAAO,CAACC,GAAR,CAAY,2BAA2BQ,GAA3B,GAAiC,eAA7C;AACA,YAAIE,eAAJ;;AACA,YAAIf,QAAO,sBAAO,KAAKH,KAAL,CAAWG,OAAlB,CAAX;;AACAA,QAAAA,QAAO,CAACgB,OAAR,CAAgB,UAAAT,YAAY,EAAE;AAC1BO,UAAAA,IAAI;AACJC,UAAAA,eAAe,GAAGR,YAAlB;AACAH,UAAAA,OAAO,CAACC,GAAR,CAAY,sCAAZ,EAAoDU,eAApD;AACAH,UAAAA,MAAM,CAACK,IAAP,CAAY,QAAZ,EAAqB;AACjB,oBAAO,eADU;AAEjB,uBAAUC,IAAI,CAACC,SAAL,CAAe;AAAC,2BAAYJ;AAAb,aAAf,CAFO,CAGjB;;AAHiB,WAArB,EAJ0B,CAS1B;;AACAX,UAAAA,OAAO,CAACC,GAAR,CAAYS,IAAI,GAAG,6BAAnB;AACH,SAXD;;AAYAF,QAAAA,MAAM,CAACK,IAAP,CAAY,QAAZ,EAAqB;AACjB,kBAAO,OADU;AAEjB,qBAAU,EAFO,CAGjB;;AAHiB,SAArB,EApBmD,CAyBnD;AACH,OA1BI,MA0BC,IAAG,CAACV,YAAD,IAAiB,KAAKV,KAAL,CAAWG,OAAX,CAAmBW,MAAnB,IAA2B,CAA/C,EAAiD;AACnD;AACAP,QAAAA,OAAO,CAACC,GAAR,CAAY,4EAAZ;AACH;AACJ;;;;EAvJgChB,S;;SAAhBC,O","sourcesContent":["import React , {Component} from 'react'\n\nexport default class NewPeer extends Component {\n\n    constructor (props) {\n        let rtcPeerConn = props.rtcPeerConn\n        let sendDataChannel = props.sendDataChannel\n        let catchDataChannel = props.catchDataChannel\n        this.callAction = this.callAction.bind(this,rtcPeerConn,sendDataChannel,catchDataChannel)\n        this.state = {\n            fileBuffer : [],\n            fileSize : [],\n            icesReq : []\n        }\n    }\n\n    callAction = (rtcPeerConn1,sendDataChannel1,catchDataChannel1) => {\n        //sendFile.disabled = true\n        console.log('Starting operation call.')\n        //let i = null\n        let [i,rtcPeerConn,sendDataChannel,catchDataChannel] = this.createPC(rtcPeerConn1,\n            sendDataChannel1,catchDataChannel1)\n        let j=i\n        [rtcPeerConn,sendDataChannel] = this.setPc(i,rtcPeerConn,sendDataChannel,catchDataChannel)\n        //displaySignalMessage('peerConnection createOffer start.')\n        console.log('peerConnection createOffer start.')\n        rtcPeerConn[i].createOffer()\n        .then(e => this.createdOffer(rtcPeerConn,e,i)).catch(this.setSessionDescriptionError)\n    }\n    \n\n    createPC = (rtcPeerConn,sendDataChannel,catchDataChannel) => {\n        const i = rtcPeerConn.length\n        const initiator = null\n        rtcPeerConn.push(initiator)\n        sendDataChannel.push(initiator)\n        catchDataChannel.push(initiator)\n        return [i,rtcPeerConn,sendDataChannel,catchDataChannel]\n    }\n    \n    \n    setPc = (i,rtcPeerConn,sendDataChannel,catchDataChannel)  => {\n        const servers = {\n            'iceServers':[{\n                'url':'stun:stun.l.google.com:19302'\n            },{'url': 'stun:stun.services.mozilla.com'}]\n        }\n        const dataChannelOptions = {\n            ordered: true//false, //not guaranteed delivery, unreliable but faster\n            //maxRetransmitTime:  1000 //miliseconds\n        }\n        //callButton.disabled = true;\n        //hangupButton.disabled = false;\n        rtcPeerConn[i] = new window.webkitRTCPeerConnection(servers);\n        console.log('Created local peer connection object rtcPeerConn index: ' + i )\n        const name = 'textMessages' + i\n        sendDataChannel[i] = rtcPeerConn[i].createDataChannel(name,dataChannelOptions)    \n        rtcPeerConn[i].ondatachannel = e=>this.receiveDataChannel(e,i,catchDataChannel);\n        rtcPeerConn[i].addEventListener('icecandidate', this.handleConnection);\n        rtcPeerConn[i].addEventListener(\n           'iceconnectionstatechange', this.handleConnectionChange);\n        return [rtcPeerConn,sendDataChannel]\n    }\n    \n    \n    receiveDataChannel = (event,i,catchDataChannel)=>{\n        console.log(\"Receiving a data channel\")\n        catchDataChannel[i] = event.channel;//seteando el canal de datos a ser el que el   \n        catchDataChannel[i].onmessage = e=>this.receiveDataChannelMessage(e,i);\n        catchDataChannel[i].onopen = e=>this.dataChannelStateChanged(e,i,catchDataChannel);\n        catchDataChannel[i].onclose = e => this.dataChannelStateChanged(e,i,catchDataChannel);\n        //return catchDataChannel;\n        this.setState({catchDataChannel})\n    }\n    \n    receiveDataChannelMessage = (event, i) => {\n        let fileBuffer = [...this.state.fileBuffer]\n        fileBuffer.push(event.data) //pushing each chunk of the incoming file\n        //into fileBuffer\n        let fileSize = this.state.fileSize\n        let receivedFileSize = this.state.receivedFileSize\n        fileSize += event.data.byteLength //updating the size of the file    \n        //fileProgress.value = fileSize  //------------------------>>>\n        if(fileSize === receivedFileSize){\n            //var received = new window.Blob(fileBuffer)\n            fileBuffer = []\n            //displaySignalMessage(\"clearing fileBuffer...\" + \"length buffer = \"+fileBuffer.length)\n            console.log(\"clearing fileBuffer...\" + \"length buffer = \"+fileBuffer.length)\n            //displaySignalMessage(\"all done... data received\")\n            console.log(\"all done... data received\")\n            //downloadLink.href = URL.createObjectURL(received)//finally when all is received\n            //the peer will get the link to download de file\n            //downloadLink.download = receivedFileName\n            //removeAllChildItems(downloadLink)\n            //downloadLink.appendChild(document.createTextNode(receivedFileName + \"(\" + \n            //fileSize + \") bytes\" ))\n            //displaySignalMessage(\"Received... \" + fileSize + \"/\" + receivedFileSize )\n            console.log(\"Received... \" + fileSize + \"/\" + receivedFileSize)\n            fileSize = 0\n            receivedFileSize = 0\n            this.setState({fileSize,receivedFileSize,fileBuffer})\n        }else{\n            this.setState({fileSize,receivedFileSize,fileBuffer})\n        }\n    }\n\n    dataChannelStateChanged(e,i,catchDataChannel){\n        if(catchDataChannel[i].readyState === 'open'){//si el readyState es abierto\n            //displaySignalMessage(\"Data Channel Opened\")\n            console.log(\"Data Channel Opened\")\n        }else{\n            //displaySignalMessage(\"data channel is : \" + catchDataChannel[i].readyState)\n            console.log(\"data channel is : \" + catchDataChannel[i].readyState)\n        }\n    }\n\n    handleConnection(event) {\n        const iceCandidate = event.candidate;\n        if(iceCandidate){\n            let icesReq = this.state.icesReq\n            icesReq.push(iceCandidate)\n            this.setState({icesReq})\n        }\n        else if (!iceCandidate && this.state.icesReq.length>0) {\n            const {socket} = this.props\n            let len = this.state.icesReq.length\n            let iter = 0\n            //displaySignalMessage(\"ICE protocol gathered \" + len + \" candidates..\" )\n            console.log(\"ICE protocol gathered \" + len + \" candidates..\")\n            let newIceCandidate\n            let icesReq = [...this.state.icesReq]\n            icesReq.forEach(iceCandidate=>{\n                iter++\n                newIceCandidate = iceCandidate\n                console.log(\"candidate created ready to be sent: \", newIceCandidate)\n                socket.emit('signal',{\n                    \"type\":\"ice candidate\",\n                    \"message\":JSON.stringify({'candidate':newIceCandidate}),\n                    //\"room\":SIGNAL_ROOM\n                })\n                //displaySignalMessage( iter +\". Sending Ice candidate ...\");\n                console.log(iter + \". Sending Ice candidate ...\")\n            })\n            socket.emit('signal',{\n                \"type\":\"noIce\",\n                \"message\":\"\",\n                //\"room\":SIGNAL_ROOM})\n            })\n            //icesReq = []\n        }else if(!iceCandidate && this.state.icesReq.length==0){\n            //displaySignalMessage(\"Candidate received is null, no candidates received yet, check your code!..\")\n            console.log(\"Candidate received is null, no candidates received yet, check your code!..\")\n        }\n    }\n\n    setSessionDescriptionError = (error) => {\n        //displaySignalMessage(`Failed to create session description: ${error.toString()}.`);\n        console.log(`Failed to create session description: ${error.toString()}.`);\n    }\n\n    handleConnectionChange = (event) => {\n        const peerConnection = event.target;\n        console.log('ICE state change event: ', event);\n        if(peerConnection.iceConnectionState == \"connected\"); //sendFile.disabled = false;\n        //displaySignalMessage(`ICE state: ` +\n        //        `${peerConnection.iceConnectionState}.`);\n        console.log(`ICE state: ` +\n                `${peerConnection.iceConnectionState}.`)\n    }\n    \n    createdOffer = (rtcPeerConn,description , i) => {\n        console.log('offer from this local peer connection: ',description.sdp)\n        //displaySignalMessage('localPeerConnection setLocalDescription start.');\n        console.log('localPeerConnection setLocalDescription start.');\n        rtcPeerConn[i].setLocalDescription(description)\n        .then(() => {\n        this.setLocalDescriptionSuccess(rtcPeerConn[i]);\n        console.log('Local description created: ',rtcPeerConn[i].localDescription)\n        //displaySignalMessage(\"Local description created..\")\n        console.log(\"Local description created..\")\n        this.sendLocalDesc(rtcPeerConn[i].localDescription)\n        }).catch(this.setSessionDescriptionError);\n    }\n\n    setLocalDescriptionSuccess = (peerConnection) => {\n        this.setDescriptionSuccess(peerConnection, 'setLocalDescription');\n    }\n\n    setDescriptionSuccess = (peerConnection, functionName) => {\n        //displaySignalMessage(`${functionName} complete.`);\n        console.log(`${functionName} complete.`)\n    }\n\n    sendLocalDesc = (desc) => {\n        const {socket} = this.props\n        console.log(\"sending local description\",desc);\n        try{\n            //displaySignalMessage(\"16. Sending Local description\");\n            console.log(\"16. Sending Local description\")\n            var sdp = {\n                type:\"SDP\",\n                message:JSON.stringify({'sdp':desc}),\n                //room:SIGNAL_ROOM\n            }\n            console.log(\"sdp sent to other nodes in sendLocalDescription: \",sdp)\n            socket.emit('signal',sdp);\n        }catch{\n            this.logError1(e,\"sending local description\");\n        }\n    }\n\n    setSessionDescriptionError = error => {\n        //displaySignalMessage(`Failed to create session description: ${error.toString()}.`);\n        console.log(`Failed to create session description: ${error.toString()}.`);\n    }\n\n    logError1 = (error,where) => {\n        displaySignalMessage(\"problems in \" + where +\" \"+ error.name + ': ' + error.message );\n    }\n    \n}"]},"metadata":{},"sourceType":"module"}